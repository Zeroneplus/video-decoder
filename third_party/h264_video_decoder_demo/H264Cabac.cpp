//
// H264Cabac.cpp
// h264_video_decoder_demo
//
// Created by: 386520874@qq.com
// Date: 2019.09.01 - 2021.02.14
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include "H264Cabac.h"
#include "CommonFunction.h"
#include "H264CommonFunc.h"
#include "H264PictureBase.h"


CH264Cabac::CH264Cabac()
{
    m_codIRange = 0;
    m_codIOffset = 0;

    memset(m_pStateIdxs, 0, sizeof(int32_t) * 1024);
    memset(m_valMPSs, 0, sizeof(int32_t) * 1024);
}


CH264Cabac::~CH264Cabac()
{

}


//-----------------------------
int CH264Cabac::get_m_and_n(int32_t ctxIdx, H264_SLIECE_TYPE slice_type, int32_t cabac_init_idc, int32_t &m, int32_t &n)
{
    int ret = 0;

    RETURN_IF_FAILED(ctxIdx < 0 || ctxIdx > 1024, -1);
    RETURN_IF_FAILED(cabac_init_idc < 0 || cabac_init_idc > 2, -1);

    //Table 9-12 – Values of variables m and n for ctxIdx from 0 to 10
    if (ctxIdx >= 0 && ctxIdx <= 10)
    {
        const int8_t mn[11][2] = 
        {
            {20, -15}, {2, 54}, {3, 74}, {20, -15}, {2, 54}, {3, 74}, {-28, 127}, {-23, 104}, {-6, 53}, {-1, 54}, 
            {7, 51}
        };

        m = mn[ctxIdx][0];
        n = mn[ctxIdx][1];
    }
    
    //Table 9-13 – Values of variables m and n for ctxIdx from 11 to 23
    else if (ctxIdx >= 11 && ctxIdx <= 23)
    {
        const int8_t mn[3][13][2] = 
        {
            {
                {23, 33}, {23, 2}, {21, 0}, {1, 9}, {0, 49}, {-37, 118}, {5, 57}, {-13, 78}, {-11, 65}, {1, 62}, 
                {12, 49}, {-4, 73}, {17, 50}
            },
            {
                {22, 25}, {34, 0}, {16, 0}, {-2, 9}, {4, 41}, {-29, 118}, {2, 65}, {-6, 71}, {-13, 79}, {5, 52}, 
                {9, 50}, {-3, 70}, {10, 54}
            },
            {
                {29, 16}, {25, 0}, {14, 0}, {-10, 51}, {-3, 62}, {-27, 99}, {26, 16}, {-4, 85}, {-24, 102}, {5, 57}, 
                {6, 57}, {-17, 73}, {14, 57}
            }
        };

        m = mn[cabac_init_idc][ctxIdx - 11][0];
        n = mn[cabac_init_idc][ctxIdx - 11][1];
    }

    //Table 9-14 – Values of variables m and n for ctxIdx from 24 to 39
    else if (ctxIdx >= 24 && ctxIdx <= 39)
    {
        const int8_t mn[3][16][2] = 
        {
            {
                {18, 64}, {9, 43}, {29, 0}, {26, 67}, {16, 90}, {9, 104}, {-46, 127}, {-20, 104}, {1, 67}, {-13, 78}, 
                {-11, 65}, {1, 62}, {-6, 86}, {-17, 95}, {-6, 61}, {9, 45}
            },
            {
                {26, 34}, {19, 22}, {40, 0}, {57, 2}, {41, 36}, {26, 69}, {-45, 127}, {-15, 101}, {-4, 76}, {-6, 71}, 
                {-13, 79}, {5, 52}, {6, 69}, {-13, 90}, {0, 52}, {8, 43}
            },
            {
                {20, 40}, {20, 10}, {29, 0}, {54, 0}, {37, 42}, {12, 97}, {-32, 127}, {-22, 117}, {-2, 74}, {-4, 85}, 
                {-24, 102}, {5, 57}, {-6, 93}, {-14, 88}, {-6, 44}, {4, 55}
            }
        };

        m = mn[cabac_init_idc][ctxIdx - 24][0];
        n = mn[cabac_init_idc][ctxIdx - 24][1];
    }
    
    //Table 9-15 – Values of variables m and n for ctxIdx from 40 to 53
    else if (ctxIdx >= 40 && ctxIdx <= 53)
    {
        const int8_t mn[3][14][2] = 
        {
            {
                {-3, 69}, {-6, 81}, {-11, 96}, {6, 55}, {7, 67}, {-5, 86}, {2, 88}, {0, 58}, {-3, 76}, {-10, 94}, 
                {5, 54}, {4, 69}, {-3, 81}, {0, 88}
            },
            {
                {-2, 69}, {-5, 82}, {-10, 96}, {2, 59}, {2, 75}, {-3, 87}, {-3, 100}, {1, 56}, {-3, 74}, {-6, 85}, 
                {0, 59}, {-3, 81}, {-7, 86}, {-5, 95}
            },
            {
                {-11, 89}, {-15, 103}, {-21, 116}, {19, 57}, {20, 58}, {4, 84}, {6, 96}, {1, 63}, {-5, 85}, {-13, 106}, 
                {5, 63}, {6, 75}, {-3, 90}, {-1, 101}
            }
        };

        m = mn[cabac_init_idc][ctxIdx - 40][0];
        n = mn[cabac_init_idc][ctxIdx - 40][1];
    }
    
    //Table 9-16 – Values of variables m and n for ctxIdx from 54 to 59, and 399 to 401
    else if (ctxIdx >= 54 && ctxIdx <= 59)
    {
        const int8_t mn[3][6][2] = 
        {
            {
                {-7, 67}, {-5, 74}, {-4, 74}, {-5, 80}, {-7, 72}, {1, 58}
            },
            {
                {-1, 66}, {-1, 77}, {1, 70}, {-2, 86}, {-5, 72}, {0, 61}
            },
            {
                {3, 55}, {-4, 79}, {-2, 75}, {-12, 97}, {-7, 50}, {1, 60}
            }
        };

        m = mn[cabac_init_idc][ctxIdx - 54][0];
        n = mn[cabac_init_idc][ctxIdx - 54][1];
    }
    else if (ctxIdx >= 399 && ctxIdx <= 401)
    {
        const int8_t mn[4][3][2] = 
        {
            {
                {31, 21}, {31, 31}, {25, 50}
            },
            {
                {12, 40}, {11, 51}, {14, 59}
            },
            {
                {25, 32}, {21, 49}, {21, 54}
            },
            {
                {21, 33}, {19, 50}, {17, 61}
            }
        };

        if (slice_type == H264_SLIECE_TYPE_I)
        {
            m = mn[0][ctxIdx - 399][0];
            n = mn[0][ctxIdx - 399][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 399][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 399][1];
        }
    }

    //Table 9-17 – Values of variables m and n for ctxIdx from 60 to 69
    else if (ctxIdx >= 60 && ctxIdx <= 69)
    {
        const int8_t mn[10][2] = 
        {
            {0, 41}, {0, 63}, {0, 63}, {0, 63}, {-9, 83}, {4, 86}, {0, 97}, {-7, 72}, {13, 41}, {3, 62}
        };

        m = mn[ctxIdx - 60][0];
        n = mn[ctxIdx - 60][1];
    }
    
    //Table 9-18 – Values of variables m and n for ctxIdx from 70 to 104
    else if (ctxIdx >= 70 && ctxIdx <= 104)
    {
        const int8_t mn[4][35][2] = 
        {
            {
                {0, 11}, {1, 55}, {0, 69}, {-17, 127}, {-13, 102}, {0, 82}, {-7, 74}, {-21, 107}, {-27, 127}, {-31, 127}, 
                {-24, 127}, {-18, 95}, {-27, 127}, {-21, 114}, {-30, 127}, {-17, 123}, {-12, 115}, {-16, 122}, {-11, 115}, {-12, 63}, 
                {-2, 68}, {-15, 84}, {-13, 104}, {-3, 70}, {-8, 93}, {-10, 90}, {-30, 127}, {-1, 74}, {-6, 97}, {-7, 91}, 
                {-20, 127}, {-4, 56}, {-5, 82}, {-7, 76}, {-22, 125}
            },
            {
                {0, 45}, {-4, 78}, {-3, 96}, {-27, 126}, {-28, 98}, {-25, 101}, {-23, 67}, {-28, 82}, {-20, 94}, {-16, 83}, 
                {-22, 110}, {-21, 91}, {-18, 102}, {-13, 93}, {-29, 127}, {-7, 92}, {-5, 89}, {-7, 96}, {-13, 108}, {-3, 46}, 
                {-1, 65}, {-1, 57}, {-9, 93}, {-3, 74}, {-9, 92}, {-8, 87}, {-23, 126}, {5, 54}, {6, 60}, {6, 59}, 
                {6, 69}, {-1, 48}, {0, 68}, {-4, 69}, {-8, 88}
            },
            {
                {13, 15}, {7, 51}, {2, 80}, {-39, 127}, {-18, 91}, {-17, 96}, {-26, 81}, {-35, 98}, {-24, 102}, {-23, 97}, 
                {-27, 119}, {-24, 99}, {-21, 110}, {-18, 102}, {-36, 127}, {0, 80}, {-5, 89}, {-7, 94}, {-4, 92}, {0, 39}, 
                {0, 65}, {-15, 84}, {-35, 127}, {-2, 73}, {-12, 104}, {-9, 91}, {-31, 127}, {3, 55}, {7, 56}, {7, 55}, 
                {8, 61}, {-3, 53}, {0, 68}, {-7, 74}, {-9, 88}
            },
            {
                {7, 34}, {-9, 88}, {-20, 127}, {-36, 127}, {-17, 91}, {-14, 95}, {-25, 84}, {-25, 86}, {-12, 89}, {-17, 91}, 
                {-31, 127}, {-14, 76}, {-18, 103}, {-13, 90}, {-37, 127}, {11, 80}, {5, 76}, {2, 84}, {5, 78}, {-6, 55}, 
                {4, 61}, {-14, 83}, {-37, 127}, {-5, 79}, {-11, 104}, {-11, 91}, {-30, 127}, {0, 65}, {-2, 79}, {0, 72}, 
                {-4, 92}, {-6, 56}, {3, 68}, {-8, 71}, {-13, 98}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I || slice_type == H264_SLIECE_TYPE_SI)
        {
            m = mn[0][ctxIdx - 70][0];
            n = mn[0][ctxIdx - 70][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 70][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 70][1];
        }
    }
    
    //Table 9-19 – Values of variables m and n for ctxIdx from 105 to 165
    else if (ctxIdx >= 105 && ctxIdx <= 165)
    {
        const int8_t mn[4][61][2] = 
        {
            {
                {-7, 93}, {-11, 87}, {-3, 77}, {-5, 71}, {-4, 63}, {-4, 68}, {-12, 84}, {-7, 62}, {-7, 65}, {8, 61},
                {5, 56}, {-2, 66}, {1, 64}, {0, 61}, {-2, 78}, {1, 50}, {7, 52}, {10, 35}, {0, 44}, {11, 38},
                {1, 45}, {0, 46}, {5, 44}, {31, 17}, {1, 51}, {7, 50}, {28, 19}, {16, 33}, {14, 62}, {-13, 108},
                {-15, 100}, {-13, 101}, {-13, 91}, {-12, 94}, {-10, 88}, {-16, 84}, {-10, 86}, {-7, 83}, {-13, 87}, {-19, 94},
                {1, 70}, {0, 72}, {-5, 74}, {18, 59}, {-8, 102}, {-15, 100}, {0, 95}, {-4, 75}, {2, 72}, {-11, 75},
                {-3, 71}, {15, 46}, {-13, 69}, {0, 62}, {0, 65}, {21, 37}, {-15, 72}, {9, 57}, {16, 54}, {0, 62},
                {12, 72}
            },
            {
                {-2, 85}, {-6, 78}, {-1, 75}, {-7, 77}, {2, 54}, {5, 50}, {-3, 68}, {1, 50}, {6, 42}, {-4, 81},
                {1, 63}, {-4, 70}, {0, 67}, {2, 57}, {-2, 76}, {11, 35}, {4, 64}, {1, 61}, {11, 35}, {18, 25},
                {12, 24}, {13, 29}, {13, 36}, {-10, 93}, {-7, 73}, {-2, 73}, {13, 46}, {9, 49}, {-7, 100}, {9, 53},
                {2, 53}, {5, 53}, {-2, 61}, {0, 56}, {0, 56}, {-13, 63}, {-5, 60}, {-1, 62}, {4, 57}, {-6, 69},
                {4, 57}, {14, 39}, {4, 51}, {13, 68}, {3, 64}, {1, 61}, {9, 63}, {7, 50}, {16, 39}, {5, 44},
                {4, 52}, {11, 48}, {-5, 60}, {-1, 59}, {0, 59}, {22, 33}, {5, 44}, {14, 43}, {-1, 78}, {0, 60},
                {9, 69}
            },
            {
                {-13, 103}, {-13, 91}, {-9, 89}, {-14, 92}, {-8, 76}, {-12, 87}, {-23, 110}, {-24, 105}, {-10, 78}, {-20, 112},
                {-17, 99}, {-78, 127}, {-70, 127}, {-50, 127}, {-46, 127}, {-4, 66}, {-5, 78}, {-4, 71}, {-8, 72}, {2, 59},
                {-1, 55}, {-7, 70}, {-6, 75}, {-8, 89}, {-34, 119}, {-3, 75}, {32, 20}, {30, 22}, {-44, 127}, {0, 54},
                {-5, 61}, {0, 58}, {-1, 60}, {-3, 61}, {-8, 67}, {-25, 84}, {-14, 74}, {-5, 65}, {5, 52}, {2, 57},
                {0, 61}, {-9, 69}, {-11, 70}, {18, 55}, {-4, 71}, {0, 58}, {7, 61}, {9, 41}, {18, 25}, {9, 32},
                {5, 43}, {9, 47}, {0, 44}, {0, 51}, {2, 46}, {19, 38}, {-4, 66}, {15, 38}, {12, 42}, {9, 34},
                {0, 89}
            },
            {
                {-4, 86}, {-12, 88}, {-5, 82}, {-3, 72}, {-4, 67}, {-8, 72}, {-16, 89}, {-9, 69}, {-1, 59}, {5, 66},
                {4, 57}, {-4, 71}, {-2, 71}, {2, 58}, {-1, 74}, {-4, 44}, {-1, 69}, {0, 62}, {-7, 51}, {-4, 47},
                {-6, 42}, {-3, 41}, {-6, 53}, {8, 76}, {-9, 78}, {-11, 83}, {9, 52}, {0, 67}, {-5, 90}, {1, 67},
                {-15, 72}, {-5, 75}, {-8, 80}, {-21, 83}, {-21, 64}, {-13, 31}, {-25, 64}, {-29, 94}, {9, 75}, {17, 63},
                {-8, 74}, {-5, 35}, {-2, 27}, {13, 91}, {3, 65}, {-7, 69}, {8, 77}, {-10, 66}, {3, 62}, {-3, 68},
                {-20, 81}, {0, 30}, {1, 7}, {-3, 23}, {-21, 74}, {16, 66}, {-23, 124}, {17, 37}, {44, -18}, {50, -34},
                {-22, 127}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I || slice_type == H264_SLIECE_TYPE_SI)
        {
            m = mn[0][ctxIdx - 105][0];
            n = mn[0][ctxIdx - 105][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 105][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 105][1];
        }
    }
    
    //Table 9-20 – Values of variables m and n for ctxIdx from 166 to 226
    else if (ctxIdx >= 166 && ctxIdx <= 226)
    {
        const int8_t mn[4][61][2] = 
        {
            {
                {24, 0}, {15, 9}, {8, 25}, {13, 18}, {15, 9}, {13, 19}, {10, 37}, {12, 18}, {6, 29}, {20, 33},
                {15, 30}, {4, 45}, {1, 58}, {0, 62}, {7, 61}, {12, 38}, {11, 45}, {15, 39}, {11, 42}, {13, 44},
                {16, 45}, {12, 41}, {10, 49}, {30, 34}, {18, 42}, {10, 55}, {17, 51}, {17, 46}, {0, 89}, {26, -19},
                {22, -17}, {26, -17}, {30, -25}, {28, -20}, {33, -23}, {37, -27}, {33, -23}, {40, -28}, {38, -17}, {33, -11},
                {40, -15}, {41, -6}, {38, 1}, {41, 17}, {30, -6}, {27, 3}, {26, 22}, {37, -16}, {35, -4}, {38, -8},
                {38, -3}, {37, 3}, {38, 5}, {42, 0}, {35, 16}, {39, 22}, {14, 48}, {27, 37}, {21, 60}, {12, 68},
                {2, 97}
            },
            {
                {11, 28}, {2, 40}, {3, 44}, {0, 49}, {0, 46}, {2, 44}, {2, 51}, {0, 47}, {4, 39}, {2, 62},
                {6, 46}, {0, 54}, {3, 54}, {2, 58}, {4, 63}, {6, 51}, {6, 57}, {7, 53}, {6, 52}, {6, 55},
                {11, 45}, {14, 36}, {8, 53}, {-1, 82}, {7, 55}, {-3, 78}, {15, 46}, {22, 31}, {-1, 84}, {25, 7},
                {30, -7}, {28, 3}, {28, 4}, {32, 0}, {34, -1}, {30, 6}, {30, 6}, {32, 9}, {31, 19}, {26, 27},
                {26, 30}, {37, 20}, {28, 34}, {17, 70}, {1, 67}, {5, 59}, {9, 67}, {16, 30}, {18, 32}, {18, 35},
                {22, 29}, {24, 31}, {23, 38}, {18, 43}, {20, 41}, {11, 63}, {9, 59}, {9, 64}, {-1, 94}, {-2, 89},
                {-9, 108}
            },
            {
                {4, 45}, {10, 28}, {10, 31}, {33, -11}, {52, -43}, {18, 15}, {28, 0}, {35, -22}, {38, -25}, {34, 0},
                {39, -18}, {32, -12}, {102, -94}, {0, 0}, {56, -15}, {33, -4}, {29, 10}, {37, -5}, {51, -29}, {39, -9},
                {52, -34}, {69, -58}, {67, -63}, {44, -5}, {32, 7}, {55, -29}, {32, 1}, {0, 0}, {27, 36}, {33, -25},
                {34, -30}, {36, -28}, {38, -28}, {38, -27}, {34, -18}, {35, -16}, {34, -14}, {32, -8}, {37, -6}, {35, 0},
                {30, 10}, {28, 18}, {26, 25}, {29, 41}, {0, 75}, {2, 72}, {8, 77}, {14, 35}, {18, 31}, {17, 35},
                {21, 30}, {17, 45}, {20, 42}, {18, 45}, {27, 26}, {16, 54}, {7, 66}, {16, 56}, {11, 73}, {10, 67},
                {-10, 116}
            },
            {
                {4, 39}, {0, 42}, {7, 34}, {11, 29}, {8, 31}, {6, 37}, {7, 42}, {3, 40}, {8, 33}, {13, 43},
                {13, 36}, {4, 47}, {3, 55}, {2, 58}, {6, 60}, {8, 44}, {11, 44}, {14, 42}, {7, 48}, {4, 56},
                {4, 52}, {13, 37}, {9, 49}, {19, 58}, {10, 48}, {12, 45}, {0, 69}, {20, 33}, {8, 63}, {35, -18},
                {33, -25}, {28, -3}, {24, 10}, {27, 0}, {34, -14}, {52, -44}, {39, -24}, {19, 17}, {31, 25}, {36, 29},
                {24, 33}, {34, 15}, {30, 20}, {22, 73}, {20, 34}, {19, 31}, {27, 44}, {19, 16}, {15, 36}, {15, 36},
                {21, 28}, {25, 21}, {30, 20}, {31, 12}, {27, 16}, {24, 42}, {0, 93}, {14, 56}, {15, 57}, {26, 38},
                {-24, 127}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I || slice_type == H264_SLIECE_TYPE_SI)
        {
            m = mn[0][ctxIdx - 166][0];
            n = mn[0][ctxIdx - 166][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 166][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 166][1];
        }
    }
    
    //Table 9-21 – Values of variables m and n for ctxIdx from 227 to 275
    else if (ctxIdx >= 227 && ctxIdx <= 275)
    {
        const int8_t mn[4][49][2] = 
        {
            {
                {-3, 71}, {-6, 42}, {-5, 50}, {-3, 54}, {-2, 62}, {0, 58}, {1, 63}, {-2, 72}, {-1, 74}, {-9, 91},
                {-5, 67}, {-5, 27}, {-3, 39}, {-2, 44}, {0, 46}, {-16, 64}, {-8, 68}, {-10, 78}, {-6, 77}, {-10, 86},
                {-12, 92}, {-15, 55}, {-10, 60}, {-6, 62}, {-4, 65}, {-12, 73}, {-8, 76}, {-7, 80}, {-9, 88}, {-17, 110},
                {-11, 97}, {-20, 84}, {-11, 79}, {-6, 73}, {-4, 74}, {-13, 86}, {-13, 96}, {-11, 97}, {-19, 117}, {-8, 78},
                {-5, 33}, {-4, 48}, {-2, 53}, {-3, 62}, {-13, 71}, {-10, 79}, {-12, 86}, {-13, 90}, {-14, 97}
            },
            {
                {-6, 76}, {-2, 44}, {0, 45}, {0, 52}, {-3, 64}, {-2, 59}, {-4, 70}, {-4, 75}, {-8, 82}, {-17, 102},
                {-9, 77}, {3, 24}, {0, 42}, {0, 48}, {0, 55}, {-6, 59}, {-7, 71}, {-12, 83}, {-11, 87}, {-30, 119},
                {1, 58}, {-3, 29}, {-1, 36}, {1, 38}, {2, 43}, {-6, 55}, {0, 58}, {0, 64}, {-3, 74}, {-10, 90},
                {0, 70}, {-4, 29}, {5, 31}, {7, 42}, {1, 59}, {-2, 58}, {-3, 72}, {-3, 81}, {-11, 97}, {0, 58},
                {8, 5}, {10, 14}, {14, 18}, {13, 27}, {2, 40}, {0, 58}, {-3, 70}, {-6, 79}, {-8, 85}
            },
            {
                {-23, 112}, {-15, 71}, {-7, 61}, {0, 53}, {-5, 66}, {-11, 77}, {-9, 80}, {-9, 84}, {-10, 87}, {-34, 127},
                {-21, 101}, {-3, 39}, {-5, 53}, {-7, 61}, {-11, 75}, {-15, 77}, {-17, 91}, {-25, 107}, {-25, 111}, {-28, 122},
                {-11, 76}, {-10, 44}, {-10, 52}, {-10, 57}, {-9, 58}, {-16, 72}, {-7, 69}, {-4, 69}, {-5, 74}, {-9, 86},
                {2, 66}, {-9, 34}, {1, 32}, {11, 31}, {5, 52}, {-2, 55}, {-2, 67}, {0, 73}, {-8, 89}, {3, 52},
                {7, 4}, {10, 8}, {17, 8}, {16, 19}, {3, 37}, {-1, 61}, {-5, 73}, {-1, 70}, {-4, 78}
            },
            {
                {-24, 115}, {-22, 82}, {-9, 62}, {0, 53}, {0, 59}, {-14, 85}, {-13, 89}, {-13, 94}, {-11, 92}, {-29, 127},
                {-21, 100}, {-14, 57}, {-12, 67}, {-11, 71}, {-10, 77}, {-21, 85}, {-16, 88}, {-23, 104}, {-15, 98}, {-37, 127},
                {-10, 82}, {-8, 48}, {-8, 61}, {-8, 66}, {-7, 70}, {-14, 75}, {-10, 79}, {-9, 83}, {-12, 92}, {-18, 108},
                {-4, 79}, {-22, 69}, {-16, 75}, {-2, 58}, {1, 58}, {-13, 78}, {-9, 83}, {-4, 81}, {-13, 99}, {-13, 81},
                {-6, 38}, {-13, 62}, {-6, 58}, {-2, 59}, {-16, 73}, {-10, 76}, {-13, 86}, {-9, 83}, {-10, 87}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I || slice_type == H264_SLIECE_TYPE_SI)
        {
            m = mn[0][ctxIdx - 227][0];
            n = mn[0][ctxIdx - 227][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 227][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 227][1];
        }
    }
    
    //Table 9-22 – Values of variables m and n for ctxIdx from 277 to 337
    else if (ctxIdx >= 277 && ctxIdx <= 337)
    {
        const int8_t mn[4][61][2] = 
        {
            {
                {-6, 93}, {-6, 84}, {-8, 79}, {0, 66}, {-1, 71}, {0, 62}, {-2, 60}, {-2, 59}, {-5, 75}, {-3, 62},
                {-4, 58}, {-9, 66}, {-1, 79}, {0, 71}, {3, 68}, {10, 44}, {-7, 62}, {15, 36}, {14, 40}, {16, 27},
                {12, 29}, {1, 44}, {20, 36}, {18, 32}, {5, 42}, {1, 48}, {10, 62}, {17, 46}, {9, 64}, {-12, 104},
                {-11, 97}, {-16, 96}, {-7, 88}, {-8, 85}, {-7, 85}, {-9, 85}, {-13, 88}, {4, 66}, {-3, 77}, {-3, 76},
                {-6, 76}, {10, 58}, {-1, 76}, {-1, 83}, {-7, 99}, {-14, 95}, {2, 95}, {0, 76}, {-5, 74}, {0, 70},
                {-11, 75}, {1, 68}, {0, 65}, {-14, 73}, {3, 62}, {4, 62}, {-1, 68}, {-13, 75}, {11, 55}, {5, 64},
                {12, 70}
            },
            {
                {-13, 106}, {-16, 106}, {-10, 87}, {-21, 114}, {-18, 110}, {-14, 98}, {-22, 110}, {-21, 106}, {-18, 103}, {-21, 107},
                {-23, 108}, {-26, 112}, {-10, 96}, {-12, 95}, {-5, 91}, {-9, 93}, {-22, 94}, {-5, 86}, {9, 67}, {-4, 80},
                {-10, 85}, {-1, 70}, {7, 60}, {9, 58}, {5, 61}, {12, 50}, {15, 50}, {18, 49}, {17, 54}, {10, 41},
                {7, 46}, {-1, 51}, {7, 49}, {8, 52}, {9, 41}, {6, 47}, {2, 55}, {13, 41}, {10, 44}, {6, 50},
                {5, 53}, {13, 49}, {4, 63}, {6, 64}, {-2, 69}, {-2, 59}, {6, 70}, {10, 44}, {9, 31}, {12, 43},
                {3, 53}, {14, 34}, {10, 38}, {-3, 52}, {13, 40}, {17, 32}, {7, 44}, {7, 38}, {13, 50}, {10, 57},
                {26, 43}
            },
            {
                {-21, 126}, {-23, 124}, {-20, 110}, {-26, 126}, {-25, 124}, {-17, 105}, {-27, 121}, {-27, 117}, {-17, 102}, {-26, 117},
                {-27, 116}, {-33, 122}, {-10, 95}, {-14, 100}, {-8, 95}, {-17, 111}, {-28, 114}, {-6, 89}, {-2, 80}, {-4, 82},
                {-9, 85}, {-8, 81}, {-1, 72}, {5, 64}, {1, 67}, {9, 56}, {0, 69}, {1, 69}, {7, 69}, {-7, 69},
                {-6, 67}, {-16, 77}, {-2, 64}, {2, 61}, {-6, 67}, {-3, 64}, {2, 57}, {-3, 65}, {-3, 66}, {0, 62},
                {9, 51}, {-1, 66}, {-2, 71}, {-2, 75}, {-1, 70}, {-9, 72}, {14, 60}, {16, 37}, {0, 47}, {18, 35},
                {11, 37}, {12, 41}, {10, 41}, {2, 48}, {12, 41}, {13, 41}, {0, 59}, {3, 50}, {19, 40}, {3, 66},
                {18, 50}
            },
            {
                {-22, 127}, {-25, 127}, {-25, 120}, {-27, 127}, {-19, 114}, {-23, 117}, {-25, 118}, {-26, 117}, {-24, 113}, {-28, 118},
                {-31, 120}, {-37, 124}, {-10, 94}, {-15, 102}, {-10, 99}, {-13, 106}, {-50, 127}, {-5, 92}, {17, 57}, {-5, 86},
                {-13, 94}, {-12, 91}, {-2, 77}, {0, 71}, {-1, 73}, {4, 64}, {-7, 81}, {5, 64}, {15, 57}, {1, 67},
                {0, 68}, {-10, 67}, {1, 68}, {0, 77}, {2, 64}, {0, 68}, {-5, 78}, {7, 55}, {5, 59}, {2, 65},
                {14, 54}, {15, 44}, {5, 60}, {2, 70}, {-2, 76}, {-18, 86}, {12, 70}, {5, 64}, {-12, 70}, {11, 55},
                {5, 56}, {0, 69}, {2, 65}, {-6, 74}, {5, 54}, {7, 54}, {-6, 76}, {-11, 82}, {-2, 77}, {-2, 77},
                {25, 42}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I || slice_type == H264_SLIECE_TYPE_SI)
        {
            m = mn[0][ctxIdx - 277][0];
            n = mn[0][ctxIdx - 277][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 277][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 277][1];
        }
    }
    
    //Table 9-23 – Values of variables m and n for ctxIdx from 338 to 398
    else if (ctxIdx >= 338 && ctxIdx <= 398)
    {
        const int8_t mn[4][61][2] = 
        {
            {
                {15, 6}, {6, 19}, {7, 16}, {12, 14}, {18, 13}, {13, 11}, {13, 15}, {15, 16}, {12, 23}, {13, 23},
                {15, 20}, {14, 26}, {14, 44}, {17, 40}, {17, 47}, {24, 17}, {21, 21}, {25, 22}, {31, 27}, {22, 29},
                {19, 35}, {14, 50}, {10, 57}, {7, 63}, {-2, 77}, {-4, 82}, {-3, 94}, {9, 69}, {-12, 109}, {36, -35},
                {36, -34}, {32, -26}, {37, -30}, {44, -32}, {34, -18}, {34, -15}, {40, -15}, {33, -7}, {35, -5}, {33, 0},
                {38, 2}, {33, 13}, {23, 35}, {13, 58}, {29, -3}, {26, 0}, {22, 30}, {31, -7}, {35, -15}, {34, -3},
                {34, 3}, {36, -1}, {34, 5}, {32, 11}, {35, 5}, {34, 12}, {39, 11}, {30, 29}, {34, 26}, {29, 39},
                {19, 66}
            },
            {
                {14, 11}, {11, 14}, {9, 11}, {18, 11}, {21, 9}, {23, -2}, {32, -15}, {32, -15}, {34, -21}, {39, -23},
                {42, -33}, {41, -31}, {46, -28}, {38, -12}, {21, 29}, {45, -24}, {53, -45}, {48, -26}, {65, -43}, {43, -19},
                {39, -10}, {30, 9}, {18, 26}, {20, 27}, {0, 57}, {-14, 82}, {-5, 75}, {-19, 97}, {-35, 125}, {27, 0},
                {28, 0}, {31, -4}, {27, 6}, {34, 8}, {30, 10}, {24, 22}, {33, 19}, {22, 32}, {26, 31}, {21, 41},
                {26, 44}, {23, 47}, {16, 65}, {14, 71}, {8, 60}, {6, 63}, {17, 65}, {21, 24}, {23, 20}, {26, 23},
                {27, 32}, {28, 23}, {28, 24}, {23, 40}, {24, 32}, {28, 29}, {23, 42}, {19, 57}, {22, 53}, {22, 61},
                {11, 86}
            },
            {
                {19, -6}, {18, -6}, {14, 0}, {26, -12}, {31, -16}, {33, -25}, {33, -22}, {37, -28}, {39, -30}, {42, -30},
                {47, -42}, {45, -36}, {49, -34}, {41, -17}, {32, 9}, {69, -71}, {63, -63}, {66, -64}, {77, -74}, {54, -39},
                {52, -35}, {41, -10}, {36, 0}, {40, -1}, {30, 14}, {28, 26}, {23, 37}, {12, 55}, {11, 65}, {37, -33},
                {39, -36}, {40, -37}, {38, -30}, {46, -33}, {42, -30}, {40, -24}, {49, -29}, {38, -12}, {40, -10}, {38, -3},
                {46, -5}, {31, 20}, {29, 30}, {25, 44}, {12, 48}, {11, 49}, {26, 45}, {22, 22}, {23, 22}, {27, 21},
                {33, 20}, {26, 28}, {30, 24}, {27, 34}, {18, 42}, {25, 39}, {18, 50}, {12, 70}, {21, 54}, {14, 71},
                {11, 83}
            },
            {
                {17, -13}, {16, -9}, {17, -12}, {27, -21}, {37, -30}, {41, -40}, {42, -41}, {48, -47}, {39, -32}, {46, -40},
                {52, -51}, {46, -41}, {52, -39}, {43, -19}, {32, 11}, {61, -55}, {56, -46}, {62, -50}, {81, -67}, {45, -20},
                {35, -2}, {28, 15}, {34, 1}, {39, 1}, {30, 17}, {20, 38}, {18, 45}, {15, 54}, {0, 79}, {36, -16},
                {37, -14}, {37, -17}, {32, 1}, {34, 15}, {29, 15}, {24, 25}, {34, 22}, {31, 16}, {35, 18}, {31, 28},
                {33, 41}, {36, 28}, {27, 47}, {21, 62}, {18, 31}, {19, 26}, {36, 24}, {24, 23}, {27, 16}, {24, 30},
                {31, 29}, {22, 41}, {22, 42}, {16, 60}, {15, 52}, {14, 60}, {3, 78}, {-16, 123}, {21, 53}, {22, 56},
                {25, 61}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I || slice_type == H264_SLIECE_TYPE_SI)
        {
            m = mn[0][ctxIdx - 338][0];
            n = mn[0][ctxIdx - 338][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 338][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 338][1];
        }
    }
    
    //Table 9-24 – Values of variables m and n for ctxIdx from 402 to 459
    else if (ctxIdx >= 402 && ctxIdx <= 459)
    {
        const int8_t mn[4][58][2] = 
        {
            {
                {-17, 120}, {-20, 112}, {-18, 114}, {-11, 85}, {-15, 92}, {-14, 89}, {-26, 71}, {-15, 81}, {-14, 80}, {0, 68},
                {-14, 70}, {-24, 56}, {-23, 68}, {-24, 50}, {-11, 74}, {23, -13}, {26, -13}, {40, -15}, {49, -14}, {44, 3},
                {45, 6}, {44, 34}, {33, 54}, {19, 82}, {-3, 75}, {-1, 23}, {1, 34}, {1, 43}, {0, 54}, {-2, 55},
                {0, 61}, {1, 64}, {0, 68}, {-9, 92}, {-14, 106}, {-13, 97}, {-15, 90}, {-12, 90}, {-18, 88}, {-10, 73},
                {-9, 79}, {-14, 86}, {-10, 73}, {-10, 70}, {-10, 69}, {-5, 66}, {-9, 64}, {-5, 58}, {2, 59}, {21, -10},
                {24, -11}, {28, -8}, {28, -1}, {29, 3}, {29, 9}, {35, 20}, {29, 36}, {14, 67}
            },
            {
                {-4, 79}, {-7, 71}, {-5, 69}, {-9, 70}, {-8, 66}, {-10, 68}, {-19, 73}, {-12, 69}, {-16, 70}, {-15, 67},
                {-20, 62}, {-19, 70}, {-16, 66}, {-22, 65}, {-20, 63}, {9, -2}, {26, -9}, {33, -9}, {39, -7}, {41, -2},
                {45, 3}, {49, 9}, {45, 27}, {36, 59}, {-6, 66}, {-7, 35}, {-7, 42}, {-8, 45}, {-5, 48}, {-12, 56},
                {-6, 60}, {-5, 62}, {-8, 66}, {-8, 76}, {-5, 85}, {-6, 81}, {-10, 77}, {-7, 81}, {-17, 80}, {-18, 73},
                {-4, 74}, {-10, 83}, {-9, 71}, {-9, 67}, {-1, 61}, {-8, 66}, {-14, 66}, {0, 59}, {2, 59}, {21, -13},
                {33, -14}, {39, -7}, {46, -2}, {51, 2}, {60, 6}, {61, 17}, {55, 34}, {42, 62}
            },
            {
                {-5, 85}, {-6, 81}, {-10, 77}, {-7, 81}, {-17, 80}, {-18, 73}, {-4, 74}, {-10, 83}, {-9, 71}, {-9, 67},
                {-1, 61}, {-8, 66}, {-14, 66}, {0, 59}, {2, 59}, {17, -10}, {32, -13}, {42, -9}, {49, -5}, {53, 0},
                {64, 3}, {68, 10}, {66, 27}, {47, 57}, {-5, 71}, {0, 24}, {-1, 36}, {-2, 42}, {-2, 52}, {-9, 57},
                {-6, 63}, {-4, 65}, {-4, 67}, {-7, 82}, {-3, 81}, {-3, 76}, {-7, 72}, {-6, 78}, {-12, 72}, {-14, 68},
                {-3, 70}, {-6, 76}, {-5, 66}, {-5, 62}, {0, 57}, {-4, 61}, {-9, 60}, {1, 54}, {2, 58}, {17, -10},
                {32, -13}, {42, -9}, {49, -5}, {53, 0}, {64, 3}, {68, 10}, {66, 27}, {47, 57}
            },
            {
                {-3, 78}, {-8, 74}, {-9, 72}, {-10, 72}, {-18, 75}, {-12, 71}, {-11, 63}, {-5, 70}, {-17, 75}, {-14, 72},
                {-16, 67}, {-8, 53}, {-14, 59}, {-9, 52}, {-11, 68}, {9, -2}, {30, -10}, {31, -4}, {33, -1}, {33, 7},
                {31, 12}, {37, 23}, {31, 38}, {20, 64}, {-9, 71}, {-7, 37}, {-8, 44}, {-11, 49}, {-10, 56}, {-12, 59},
                {-8, 63}, {-9, 67}, {-6, 68}, {-10, 79}, {-3, 78}, {-8, 74}, {-9, 72}, {-10, 72}, {-18, 75}, {-12, 71},
                {-11, 63}, {-5, 70}, {-17, 75}, {-14, 72}, {-16, 67}, {-8, 53}, {-14, 59}, {-9, 52}, {-11, 68}, {9, -2},
                {30, -10}, {31, -4}, {33, -1}, {33, 7}, {31, 12}, {37, 23}, {31, 38}, {20, 64}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I)
        {
            m = mn[0][ctxIdx - 402][0];
            n = mn[0][ctxIdx - 402][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 402][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 402][1];
        }
    }
    
    //Table 9-25 – Values of variables m and n for ctxIdx from 460 to 483
    else if (ctxIdx >= 460 && ctxIdx <= 483)
    {
        const int8_t mn[4][24][2] = 
        {
            {
                {-17, 123}, {-12, 115}, {-16, 122}, {-11, 115}, {-12, 63}, {-2, 68}, {-15, 84}, {-13, 104}, {-3, 70}, {-8, 93},
                {-10, 90}, {-30, 127}, {-17, 123}, {-12, 115}, {-16, 122}, {-11, 115}, {-12, 63}, {-2, 68}, {-15, 84}, {-13, 104},
                {-3, 70}, {-8, 93}, {-10, 90}, {-30, 127}
            },
            {
                {-7, 92}, {-5, 89}, {-7, 96}, {-13, 108}, {-3, 46}, {-1, 65}, {-1, 57}, {-9, 93}, {-3, 74}, {-9, 92},
                {-8, 87}, {-23, 126}, {-7, 92}, {-5, 89}, {-7, 96}, {-13, 108}, {-3, 46}, {-1, 65}, {-1, 57}, {-9, 93},
                {-3, 74}, {-9, 92}, {-8, 87}, {-23, 126}
            },
            {
                {0, 80}, {-5, 89}, {-7, 94}, {-4, 92}, {0, 39}, {0, 65}, {-15, 84}, {-35, 127}, {-2, 73}, {-12, 104},
                {-9, 91}, {-31, 127}, {0, 80}, {-5, 89}, {-7, 94}, {-4, 92}, {0, 39}, {0, 65}, {-15, 84}, {-35, 127},
                {-2, 73}, {-12, 104}, {-9, 91}, {-31, 127}
            },
            {
                {11, 80}, {5, 76}, {2, 84}, {5, 78}, {-6, 55}, {4, 61}, {-14, 83}, {-37, 127}, {-5, 79}, {-11, 104},
                {-11, 91}, {-30, 127}, {11, 80}, {5, 76}, {2, 84}, {5, 78}, {-6, 55}, {4, 61}, {-14, 83}, {-37, 127},
                {-5, 79}, {-11, 104}, {-11, 91}, {-30, 127}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I || slice_type == H264_SLIECE_TYPE_SI)
        {
            m = mn[0][ctxIdx - 460][0];
            n = mn[0][ctxIdx - 460][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 460][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 460][1];
        }
    }
    
    //Table 9-26 – Values of variables m and n for ctxIdx from 484 to 571
    else if (ctxIdx >= 484 && ctxIdx <= 571)
    {
        const int8_t mn[4][88][2] = 
        {
            {
                {-7, 93}, {-11, 87}, {-3, 77}, {-5, 71}, {-4, 63}, {-4, 68}, {-12, 84}, {-7, 62}, {-7, 65}, {8, 61},
                {5, 56}, {-2, 66}, {1, 64}, {0, 61}, {-2, 78}, {1, 50}, {7, 52}, {10, 35}, {0, 44}, {11, 38},
                {1, 45}, {0, 46}, {5, 44}, {31, 17}, {1, 51}, {7, 50}, {28, 19}, {16, 33}, {14, 62}, {-13, 108},
                {-15, 100}, {-13, 101}, {-13, 91}, {-12, 94}, {-10, 88}, {-16, 84}, {-10, 86}, {-7, 83}, {-13, 87}, {-19, 94},
                {1, 70}, {0, 72}, {-5, 74}, {18, 59}, {-7, 93}, {-11, 87}, {-3, 77}, {-5, 71}, {-4, 63}, {-4, 68},
                {-12, 84}, {-7, 62}, {-7, 65}, {8, 61}, {5, 56}, {-2, 66}, {1, 64}, {0, 61}, {-2, 78}, {1, 50},
                {7, 52}, {10, 35}, {0, 44}, {11, 38}, {1, 45}, {0, 46}, {5, 44}, {31, 17}, {1, 51}, {7, 50},
                {28, 19}, {16, 33}, {14, 62}, {-13, 108}, {-15, 100}, {-13, 101}, {-13, 91}, {-12, 94}, {-10, 88}, {-16, 84},
                {-10, 86}, {-7, 83}, {-13, 87}, {-19, 94}, {1, 70}, {0, 72}, {-5, 74}, {18, 59}
            },
            {
                {-2, 85}, {-6, 78}, {-1, 75}, {-7, 77}, {2, 54}, {5, 50}, {-3, 68}, {1, 50}, {6, 42}, {-4, 81},
                {1, 63}, {-4, 70}, {0, 67}, {2, 57}, {-2, 76}, {11, 35}, {4, 64}, {1, 61}, {11, 35}, {18, 25},
                {12, 24}, {13, 29}, {13, 36}, {-10, 93}, {-7, 73}, {-2, 73}, {13, 46}, {9, 49}, {-7, 100}, {9, 53},
                {2, 53}, {5, 53}, {-2, 61}, {0, 56}, {0, 56}, {-13, 63}, {-5, 60}, {-1, 62}, {4, 57}, {-6, 69},
                {4, 57}, {14, 39}, {4, 51}, {13, 68}, {-2, 85}, {-6, 78}, {-1, 75}, {-7, 77}, {2, 54}, {5, 50},
                {-3, 68}, {1, 50}, {6, 42}, {-4, 81}, {1, 63}, {-4, 70}, {0, 67}, {2, 57}, {-2, 76}, {11, 35},
                {4, 64}, {1, 61}, {11, 35}, {18, 25}, {12, 24}, {13, 29}, {13, 36}, {-10, 93}, {-7, 73}, {-2, 73},
                {13, 46}, {9, 49}, {-7, 100}, {9, 53}, {2, 53}, {5, 53}, {-2, 61}, {0, 56}, {0, 56}, {-13, 63},
                {-5, 60}, {-1, 62}, {4, 57}, {-6, 69}, {4, 57}, {14, 39}, {4, 51}, {13, 68}

            },
            {
                {-13, 103}, {-13, 91}, {-9, 89}, {-14, 92}, {-8, 76}, {-12, 87}, {-23, 110}, {-24, 105}, {-10, 78}, {-20, 112},
                {-17, 99}, {-78, 127}, {-70, 127}, {-50, 127}, {-46, 127}, {-4, 66}, {-5, 78}, {-4, 71}, {-8, 72}, {2, 59},
                {-1, 55}, {-7, 70}, {-6, 75}, {-8, 89}, {-34, 119}, {-3, 75}, {32, 20}, {30, 22}, {-44, 127}, {0, 54},
                {-5, 61}, {0, 58}, {-1, 60}, {-3, 61}, {-8, 67}, {-25, 84}, {-14, 74}, {-5, 65}, {5, 52}, {2, 57},
                {0, 61}, {-9, 69}, {-11, 70}, {18, 55}, {-13, 103}, {-13, 91}, {-9, 89}, {-14, 92}, {-8, 76}, {-12, 87},
                {-23, 110}, {-24, 105}, {-10, 78}, {-20, 112}, {-17, 99}, {-78, 127}, {-70, 127}, {-50, 127}, {-46, 127}, {-4, 66},
                {-5, 78}, {-4, 71}, {-8, 72}, {2, 59}, {-1, 55}, {-7, 70}, {-6, 75}, {-8, 89}, {-34, 119}, {-3, 75},
                {32, 20}, {30, 22}, {-44, 127}, {0, 54}, {-5, 61}, {0, 58}, {-1, 60}, {-3, 61}, {-8, 67}, {-25, 84},
                {-14, 74}, {-5, 65}, {5, 52}, {2, 57}, {0, 61}, {-9, 69}, {-11, 70}, {18, 55}
            },
            {
                {-4, 86}, {-12, 88}, {-5, 82}, {-3, 72}, {-4, 67}, {-8, 72}, {-16, 89}, {-9, 69}, {-1, 59}, {5, 66},
                {4, 57}, {-4, 71}, {-2, 71}, {2, 58}, {-1, 74}, {-4, 44}, {-1, 69}, {0, 62}, {-7, 51}, {-4, 47},
                {-6, 42}, {-3, 41}, {-6, 53}, {8, 76}, {-9, 78}, {-11, 83}, {9, 52}, {0, 67}, {-5, 90}, {1, 67},
                {-15, 72}, {-5, 75}, {-8, 80}, {-21, 83}, {-21, 64}, {-13, 31}, {-25, 64}, {-29, 94}, {9, 75}, {17, 63},
                {-8, 74}, {-5, 35}, {-2, 27}, {13, 91}, {-4, 86}, {-12, 88}, {-5, 82}, {-3, 72}, {-4, 67}, {-8, 72},
                {-16, 89}, {-9, 69}, {-1, 59}, {5, 66}, {4, 57}, {-4, 71}, {-2, 71}, {2, 58}, {-1, 74}, {-4, 44},
                {-1, 69}, {0, 62}, {-7, 51}, {-4, 47}, {-6, 42}, {-3, 41}, {-6, 53}, {8, 76}, {-9, 78}, {-11, 83},
                {9, 52}, {0, 67}, {-5, 90}, {1, 67}, {-15, 72}, {-5, 75}, {-8, 80}, {-21, 83}, {-21, 64}, {-13, 31},
                {-25, 64}, {-29, 94}, {9, 75}, {17, 63}, {-8, 74}, {-5, 35}, {-2, 27}, {13, 91}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I || slice_type == H264_SLIECE_TYPE_SI)
        {
            m = mn[0][ctxIdx - 484][0];
            n = mn[0][ctxIdx - 484][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 484][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 484][1];
        }
    }
    
    //Table 9-27 – Values of variables m and n for ctxIdx from 572 to 659
    else if (ctxIdx >= 572 && ctxIdx <= 659)
    {
        const int8_t mn[4][88][2] = 
        {
            {
                {24, 0}, {15, 9}, {8, 25}, {13, 18}, {15, 9}, {13, 19}, {10, 37}, {12, 18}, {6, 29}, {20, 33},
                {15, 30}, {4, 45}, {1, 58}, {0, 62}, {7, 61}, {12, 38}, {11, 45}, {15, 39}, {11, 42}, {13, 44},
                {16, 45}, {12, 41}, {10, 49}, {30, 34}, {18, 42}, {10, 55}, {17, 51}, {17, 46}, {0, 89}, {26, -19},
                {22, -17}, {26, -17}, {30, -25}, {28, -20}, {33, -23}, {37, -27}, {33, -23}, {40, -28}, {38, -17}, {33, -11},
                {40, -15}, {41, -6}, {38, 1}, {41, 17}, {24, 0}, {15, 9}, {8, 25}, {13, 18}, {15, 9}, {13, 19},
                {10, 37}, {12, 18}, {6, 29}, {20, 33}, {15, 30}, {4, 45}, {1, 58}, {0, 62}, {7, 61}, {12, 38},
                {11, 45}, {15, 39}, {11, 42}, {13, 44}, {16, 45}, {12, 41}, {10, 49}, {30, 34}, {18, 42}, {10, 55},
                {17, 51}, {17, 46}, {0, 89}, {26, -19}, {22, -17}, {26, -17}, {30, -25}, {28, -20}, {33, -23}, {37, -27},
                {33, -23}, {40, -28}, {38, -17}, {33, -11}, {40, -15}, {41, -6}, {38, 1}, {41, 17}
            },
            {
                {11, 28}, {2, 40}, {3, 44}, {0, 49}, {0, 46}, {2, 44}, {2, 51}, {0, 47}, {4, 39}, {2, 62},
                {6, 46}, {0, 54}, {3, 54}, {2, 58}, {4, 63}, {6, 51}, {6, 57}, {7, 53}, {6, 52}, {6, 55},
                {11, 45}, {14, 36}, {8, 53}, {-1, 82}, {7, 55}, {-3, 78}, {15, 46}, {22, 31}, {-1, 84}, {25, 7},
                {30, -7}, {28, 3}, {28, 4}, {32, 0}, {34, -1}, {30, 6}, {30, 6}, {32, 9}, {31, 19}, {26, 27},
                {26, 30}, {37, 20}, {28, 34}, {17, 70}, {11, 28}, {2, 40}, {3, 44}, {0, 49}, {0, 46}, {2, 44},
                {2, 51}, {0, 47}, {4, 39}, {2, 62}, {6, 46}, {0, 54}, {3, 54}, {2, 58}, {4, 63}, {6, 51},
                {6, 57}, {7, 53}, {6, 52}, {6, 55}, {11, 45}, {14, 36}, {8, 53}, {-1, 82}, {7, 55}, {-3, 78},
                {15, 46}, {22, 31}, {-1, 84}, {25, 7}, {30, -7}, {28, 3}, {28, 4}, {32, 0}, {34, -1}, {30, 6},
                {30, 6}, {32, 9}, {31, 19}, {26, 27}, {26, 30}, {37, 20}, {28, 34}, {17, 70}
            },
            {
                {4, 45}, {10, 28}, {10, 31}, {33, -11}, {52, -43}, {18, 15}, {28, 0}, {35, -22}, {38, -25}, {34, 0},
                {39, -18}, {32, -12}, {102, -94}, {0, 0}, {56, -15}, {33, -4}, {29, 10}, {37, -5}, {51, -29}, {39, -9},
                {52, -34}, {69, -58}, {67, -63}, {44, -5}, {32, 7}, {55, -29}, {32, 1}, {0, 0}, {27, 36}, {33, -25},
                {34, -30}, {36, -28}, {38, -28}, {38, -27}, {34, -18}, {35, -16}, {34, -14}, {32, -8}, {37, -6}, {35, 0},
                {30, 10}, {28, 18}, {26, 25}, {29, 41}, {4, 45}, {10, 28}, {10, 31}, {33, -11}, {52, -43}, {18, 15},
                {28, 0}, {35, -22}, {38, -25}, {34, 0}, {39, -18}, {32, -12}, {102, -94}, {0, 0}, {56, -15}, {33, -4},
                {29, 10}, {37, -5}, {51, -29}, {39, -9}, {52, -34}, {69, -58}, {67, -63}, {44, -5}, {32, 7}, {55, -29},
                {32, 1}, {0, 0}, {27, 36}, {33, -25}, {34, -30}, {36, -28}, {38, -28}, {38, -27}, {34, -18}, {35, -16},
                {34, -14}, {32, -8}, {37, -6}, {35, 0}, {30, 10}, {28, 18}, {26, 25}, {29, 41}
            },
            {
                {4, 39}, {0, 42}, {7, 34}, {11, 29}, {8, 31}, {6, 37}, {7, 42}, {3, 40}, {8, 33}, {13, 43},
                {13, 36}, {4, 47}, {3, 55}, {2, 58}, {6, 60}, {8, 44}, {11, 44}, {14, 42}, {7, 48}, {4, 56},
                {4, 52}, {13, 37}, {9, 49}, {19, 58}, {10, 48}, {12, 45}, {0, 69}, {20, 33}, {8, 63}, {35, -18},
                {33, -25}, {28, -3}, {24, 10}, {27, 0}, {34, -14}, {52, -44}, {39, -24}, {19, 17}, {31, 25}, {36, 29},
                {24, 33}, {34, 15}, {30, 20}, {22, 73}, {4, 39}, {0, 42}, {7, 34}, {11, 29}, {8, 31}, {6, 37},
                {7, 42}, {3, 40}, {8, 33}, {13, 43}, {13, 36}, {4, 47}, {3, 55}, {2, 58}, {6, 60}, {8, 44},
                {11, 44}, {14, 42}, {7, 48}, {4, 56}, {4, 52}, {13, 37}, {9, 49}, {19, 58}, {10, 48}, {12, 45},
                {0, 69}, {20, 33}, {8, 63}, {35, -18}, {33, -25}, {28, -3}, {24, 10}, {27, 0}, {34, -14}, {52, -44},
                {39, -24}, {19, 17}, {31, 25}, {36, 29}, {24, 33}, {34, 15}, {30, 20}, {22, 73}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I || slice_type == H264_SLIECE_TYPE_SI)
        {
            m = mn[0][ctxIdx - 572][0];
            n = mn[0][ctxIdx - 572][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 572][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 572][1];
        }
    }
    
    //Table 9-28 – Values of variables m and n for ctxIdx from 660 to 717
    else if (ctxIdx >= 660 && ctxIdx <= 717)
    {
        const int8_t mn[4][58][2] = 
        {
            {
                {-17, 120}, {-20, 112}, {-18, 114}, {-11, 85}, {-15, 92}, {-14, 89}, {-26, 71}, {-15, 81}, {-14, 80}, {0, 68},
                {-14, 70}, {-24, 56}, {-23, 68}, {-24, 50}, {-11, 74}, {-14, 106}, {-13, 97}, {-15, 90}, {-12, 90}, {-18, 88},
                {-10, 73}, {-9, 79}, {-14, 86}, {-10, 73}, {-10, 70}, {-10, 69}, {-5, 66}, {-9, 64}, {-5, 58}, {2, 59},
                {23, -13}, {26, -13}, {40, -15}, {49, -14}, {44, 3}, {45, 6}, {44, 34}, {33, 54}, {19, 82}, {21, -10},
                {24, -11}, {28, -8}, {28, -1}, {29, 3}, {29, 9}, {35, 20}, {29, 36}, {14, 67}, {-3, 75}, {-1, 23},
                {1, 34}, {1, 43}, {0, 54}, {-2, 55}, {0, 61}, {1, 64}, {0, 68}, {-9, 92}
            },
            {
                {-4, 79}, {-7, 71}, {-5, 69}, {-9, 70}, {-8, 66}, {-10, 68}, {-19, 73}, {-12, 69}, {-16, 70}, {-15, 67},
                {-20, 62}, {-19, 70}, {-16, 66}, {-22, 65}, {-20, 63}, {-5, 85}, {-6, 81}, {-10, 77}, {-7, 81}, {-17, 80},
                {-18, 73}, {-4, 74}, {-10, 83}, {-9, 71}, {-9, 67}, {-1, 61}, {-8, 66}, {-14, 66}, {0, 59}, {2, 59},
                {9, -2}, {26, -9}, {33, -9}, {39, -7}, {41, -2}, {45, 3}, {49, 9}, {45, 27}, {36, 59}, {21, -13},
                {33, -14}, {39, -7}, {46, -2}, {51, 2}, {60, 6}, {61, 17}, {55, 34}, {42, 62}, {-6, 66}, {-7, 35},
                {-7, 42}, {-8, 45}, {-5, 48}, {-12, 56}, {-6, 60}, {-5, 62}, {-8, 66}, {-8, 76}
            },
            {
                {-5, 85}, {-6, 81}, {-10, 77}, {-7, 81}, {-17, 80}, {-18, 73}, {-4, 74}, {-10, 83}, {-9, 71}, {-9, 67},
                {-1, 61}, {-8, 66}, {-14, 66}, {0, 59}, {2, 59}, {-3, 81}, {-3, 76}, {-7, 72}, {-6, 78}, {-12, 72},
                {-14, 68}, {-3, 70}, {-6, 76}, {-5, 66}, {-5, 62}, {0, 57}, {-4, 61}, {-9, 60}, {1, 54}, {2, 58},
                {17, -10}, {32, -13}, {42, -9}, {49, -5}, {53, 0}, {64, 3}, {68, 10}, {66, 27}, {47, 57}, {17, -10},
                {32, -13}, {42, -9}, {49, -5}, {53, 0}, {64, 3}, {68, 10}, {66, 27}, {47, 57}, {-5, 71}, {0, 24},
                {-1, 36}, {-2, 42}, {-2, 52}, {-9, 57}, {-6, 63}, {-4, 65}, {-4, 67}, {-7, 82}
            },
            {
                {-3, 78}, {-8, 74}, {-9, 72}, {-10, 72}, {-18, 75}, {-12, 71}, {-11, 63}, {-5, 70}, {-17, 75}, {-14, 72},
                {-16, 67}, {-8, 53}, {-14, 59}, {-9, 52}, {-11, 68}, {-3, 78}, {-8, 74}, {-9, 72}, {-10, 72}, {-18, 75},
                {-12, 71}, {-11, 63}, {-5, 70}, {-17, 75}, {-14, 72}, {-16, 67}, {-8, 53}, {-14, 59}, {-9, 52}, {-11, 68},
                {9, -2}, {30, -10}, {31, -4}, {33, -1}, {33, 7}, {31, 12}, {37, 23}, {31, 38}, {20, 64}, {9, -2},
                {30, -10}, {31, -4}, {33, -1}, {33, 7}, {31, 12}, {37, 23}, {31, 38}, {20, 64}, {-9, 71}, {-7, 37},
                {-8, 44}, {-11, 49}, {-10, 56}, {-12, 59}, {-8, 63}, {-9, 67}, {-6, 68}, {-10, 79}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I)
        {
            m = mn[0][ctxIdx - 660][0];
            n = mn[0][ctxIdx - 660][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 660][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 660][1];
        }
    }
    
    //Table 9-29 – Values of variables m and n for ctxIdx from 718 to 775
    else if (ctxIdx >= 718 && ctxIdx <= 775)
    {
        const int8_t mn[4][58][2] = 
        {
            {
                {-17, 120}, {-20, 112}, {-18, 114}, {-11, 85}, {-15, 92}, {-14, 89}, {-26, 71}, {-15, 81}, {-14, 80}, {0, 68},
                {-14, 70}, {-24, 56}, {-23, 68}, {-24, 50}, {-11, 74}, {-14, 106}, {-13, 97}, {-15, 90}, {-12, 90}, {-18, 88},
                {-10, 73}, {-9, 79}, {-14, 86}, {-10, 73}, {-10, 70}, {-10, 69}, {-5, 66}, {-9, 64}, {-5, 58}, {2, 59},
                {23, -13}, {26, -13}, {40, -15}, {49, -14}, {44, 3}, {45, 6}, {44, 34}, {33, 54}, {19, 82}, {21, -10},
                {24, -11}, {28, -8}, {28, -1}, {29, 3}, {29, 9}, {35, 20}, {29, 36}, {14, 67}, {-3, 75}, {-1, 23},
                {1, 34}, {1, 43}, {0, 54}, {-2, 55}, {0, 61}, {1, 64}, {0, 68}, {-9, 92}
            },
            {
                {-4, 79}, {-7, 71}, {-5, 69}, {-9, 70}, {-8, 66}, {-10, 68}, {-19, 73}, {-12, 69}, {-16, 70}, {-15, 67},
                {-20, 62}, {-19, 70}, {-16, 66}, {-22, 65}, {-20, 63}, {-5, 85}, {-6, 81}, {-10, 77}, {-7, 81}, {-17, 80},
                {-18, 73}, {-4, 74}, {-10, 83}, {-9, 71}, {-9, 67}, {-1, 61}, {-8, 66}, {-14, 66}, {0, 59}, {2, 59},
                {9, -2}, {26, -9}, {33, -9}, {39, -7}, {41, -2}, {45, 3}, {49, 9}, {45, 27}, {36, 59}, {21, -13},
                {33, -14}, {39, -7}, {46, -2}, {51, 2}, {60, 6}, {61, 17}, {55, 34}, {42, 62}, {-6, 66}, {-7, 35},
                {-7, 42}, {-8, 45}, {-5, 48}, {-12, 56}, {-6, 60}, {-5, 62}, {-8, 66}, {-8, 76}
            },
            {
                {-5, 85}, {-6, 81}, {-10, 77}, {-7, 81}, {-17, 80}, {-18, 73}, {-4, 74}, {-10, 83}, {-9, 71}, {-9, 67},
                {-1, 61}, {-8, 66}, {-14, 66}, {0, 59}, {2, 59}, {-3, 81}, {-3, 76}, {-7, 72}, {-6, 78}, {-12, 72},
                {-14, 68}, {-3, 70}, {-6, 76}, {-5, 66}, {-5, 62}, {0, 57}, {-4, 61}, {-9, 60}, {1, 54}, {2, 58},
                {17, -10}, {32, -13}, {42, -9}, {49, -5}, {53, 0}, {64, 3}, {68, 10}, {66, 27}, {47, 57}, {17, -10},
                {32, -13}, {42, -9}, {49, -5}, {53, 0}, {64, 3}, {68, 10}, {66, 27}, {47, 57}, {-5, 71}, {0, 24},
                {-1, 36}, {-2, 42}, {-2, 52}, {-9, 57}, {-6, 63}, {-4, 65}, {-4, 67}, {-7, 82}
            },
            {
                {-3, 78}, {-8, 74}, {-9, 72}, {-10, 72}, {-18, 75}, {-12, 71}, {-11, 63}, {-5, 70}, {-17, 75}, {-14, 72},
                {-16, 67}, {-8, 53}, {-14, 59}, {-9, 52}, {-11, 68}, {-3, 78}, {-8, 74}, {-9, 72}, {-10, 72}, {-18, 75},
                {-12, 71}, {-11, 63}, {-5, 70}, {-17, 75}, {-14, 72}, {-16, 67}, {-8, 53}, {-14, 59}, {-9, 52}, {-11, 68},
                {9, -2}, {30, -10}, {31, -4}, {33, -1}, {33, 7}, {31, 12}, {37, 23}, {31, 38}, {20, 64}, {9, -2},
                {30, -10}, {31, -4}, {33, -1}, {33, 7}, {31, 12}, {37, 23}, {31, 38}, {20, 64}, {-9, 71}, {-7, 37},
                {-8, 44}, {-11, 49}, {-10, 56}, {-12, 59}, {-8, 63}, {-9, 67}, {-6, 68}, {-10, 79}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I)
        {
            m = mn[0][ctxIdx - 718][0];
            n = mn[0][ctxIdx - 718][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 718][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 718][1];
        }
    }
    
    //Table 9-30 – Values of variables m and n for ctxIdx from 776 to 863
    else if (ctxIdx >= 776 && ctxIdx <= 863)
    {
        const int8_t mn[4][88][2] = 
        {
            {
                {-6, 93}, {-6, 84}, {-8, 79}, {0, 66}, {-1, 71}, {0, 62}, {-2, 60}, {-2, 59}, {-5, 75}, {-3, 62},
                {-4, 58}, {-9, 66}, {-1, 79}, {0, 71}, {3, 68}, {10, 44}, {-7, 62}, {15, 36}, {14, 40}, {16, 27},
                {12, 29}, {1, 44}, {20, 36}, {18, 32}, {5, 42}, {1, 48}, {10, 62}, {17, 46}, {9, 64}, {-12, 104},
                {-11, 97}, {-16, 96}, {-7, 88}, {-8, 85}, {-7, 85}, {-9, 85}, {-13, 88}, {4, 66}, {-3, 77}, {-3, 76},
                {-6, 76}, {10, 58}, {-1, 76}, {-1, 83}, {-6, 93}, {-6, 84}, {-8, 79}, {0, 66}, {-1, 71}, {0, 62},
                {-2, 60}, {-2, 59}, {-5, 75}, {-3, 62}, {-4, 58}, {-9, 66}, {-1, 79}, {0, 71}, {3, 68}, {10, 44},
                {-7, 62}, {15, 36}, {14, 40}, {16, 27}, {12, 29}, {1, 44}, {20, 36}, {18, 32}, {5, 42}, {1, 48},
                {10, 62}, {17, 46}, {9, 64}, {-12, 104}, {-11, 97}, {-16, 96}, {-7, 88}, {-8, 85}, {-7, 85}, {-9, 85},
                {-13, 88}, {4, 66}, {-3, 77}, {-3, 76}, {-6, 76}, {10, 58}, {-1, 76}, {-1, 83}
            },
            {
                {-13, 106}, {-16, 106}, {-10, 87}, {-21, 114}, {-18, 110}, {-14, 98}, {-22, 110}, {-21, 106}, {-18, 103}, {-21, 107},
                {-23, 108}, {-26, 112}, {-10, 96}, {-12, 95}, {-5, 91}, {-9, 93}, {-22, 94}, {-5, 86}, {9, 67}, {-4, 80},
                {-10, 85}, {-1, 70}, {7, 60}, {9, 58}, {5, 61}, {12, 50}, {15, 50}, {18, 49}, {17, 54}, {10, 41},
                {7, 46}, {-1, 51}, {7, 49}, {8, 52}, {9, 41}, {6, 47}, {2, 55}, {13, 41}, {10, 44}, {6, 50},
                {5, 53}, {13, 49}, {4, 63}, {6, 64}, {-13, 106}, {-16, 106}, {-10, 87}, {-21, 114}, {-18, 110}, {-14, 98},
                {-22, 110}, {-21, 106}, {-18, 103}, {-21, 107}, {-23, 108}, {-26, 112}, {-10, 96}, {-12, 95}, {-5, 91}, {-9, 93},
                {-22, 94}, {-5, 86}, {9, 67}, {-4, 80}, {-10, 85}, {-1, 70}, {7, 60}, {9, 58}, {5, 61}, {12, 50},
                {15, 50}, {18, 49}, {17, 54}, {10, 41}, {7, 46}, {-1, 51}, {7, 49}, {8, 52}, {9, 41}, {6, 47},
                {2, 55}, {13, 41}, {10, 44}, {6, 50}, {5, 53}, {13, 49}, {4, 63}, {6, 64}
            },
            {
                {-21, 126}, {-23, 124}, {-20, 110}, {-26, 126}, {-25, 124}, {-17, 105}, {-27, 121}, {-27, 117}, {-17, 102}, {-26, 117},
                {-27, 116}, {-33, 122}, {-10, 95}, {-14, 100}, {-8, 95}, {-17, 111}, {-28, 114}, {-6, 89}, {-2, 80}, {-4, 82},
                {-9, 85}, {-8, 81}, {-1, 72}, {5, 64}, {1, 67}, {9, 56}, {0, 69}, {1, 69}, {7, 69}, {-7, 69},
                {-6, 67}, {-16, 77}, {-2, 64}, {2, 61}, {-6, 67}, {-3, 64}, {2, 57}, {-3, 65}, {-3, 66}, {0, 62},
                {9, 51}, {-1, 66}, {-2, 71}, {-2, 75}, {-21, 126}, {-23, 124}, {-20, 110}, {-26, 126}, {-25, 124}, {-17, 105},
                {-27, 121}, {-27, 117}, {-17, 102}, {-26, 117}, {-27, 116}, {-33, 122}, {-10, 95}, {-14, 100}, {-8, 95}, {-17, 111},
                {-28, 114}, {-6, 89}, {-2, 80}, {-4, 82}, {-9, 85}, {-8, 81}, {-1, 72}, {5, 64}, {1, 67}, {9, 56},
                {0, 69}, {1, 69}, {7, 69}, {-7, 69}, {-6, 67}, {-16, 77}, {-2, 64}, {2, 61}, {-6, 67}, {-3, 64},
                {2, 57}, {-3, 65}, {-3, 66}, {0, 62}, {9, 51}, {-1, 66}, {-2, 71}, {-2, 75}
            },
            {
                {-22, 127}, {-25, 127}, {-25, 120}, {-27, 127}, {-19, 114}, {-23, 117}, {-25, 118}, {-26, 117}, {-24, 113}, {-28, 118},
                {-31, 120}, {-37, 124}, {-10, 94}, {-15, 102}, {-10, 99}, {-13, 106}, {-50, 127}, {-5, 92}, {17, 57}, {-5, 86},
                {-13, 94}, {-12, 91}, {-2, 77}, {0, 71}, {-1, 73}, {4, 64}, {-7, 81}, {5, 64}, {15, 57}, {1, 67},
                {0, 68}, {-10, 67}, {1, 68}, {0, 77}, {2, 64}, {0, 68}, {-5, 78}, {7, 55}, {5, 59}, {2, 65},
                {14, 54}, {15, 44}, {5, 60}, {2, 70}, {-22, 127}, {-25, 127}, {-25, 120}, {-27, 127}, {-19, 114}, {-23, 117},
                {-25, 118}, {-26, 117}, {-24, 113}, {-28, 118}, {-31, 120}, {-37, 124}, {-10, 94}, {-15, 102}, {-10, 99}, {-13, 106},
                {-50, 127}, {-5, 92}, {17, 57}, {-5, 86}, {-13, 94}, {-12, 91}, {-2, 77}, {0, 71}, {-1, 73}, {4, 64},
                {-7, 81}, {5, 64}, {15, 57}, {1, 67}, {0, 68}, {-10, 67}, {1, 68}, {0, 77}, {2, 64}, {0, 68},
                {-5, 78}, {7, 55}, {5, 59}, {2, 65}, {14, 54}, {15, 44}, {5, 60}, {2, 70}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I || slice_type == H264_SLIECE_TYPE_SI)
        {
            m = mn[0][ctxIdx - 776][0];
            n = mn[0][ctxIdx - 776][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 776][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 776][1];
        }
    }
    
    //Table 9-31 – Values of variables m and n for ctxIdx from 864 to 951
    else if (ctxIdx >= 864 && ctxIdx <= 951)
    {
        const int8_t mn[4][88][2] = 
        {
            {
                {15, 6}, {6, 19}, {7, 16}, {12, 14}, {18, 13}, {13, 11}, {13, 15}, {15, 16}, {12, 23}, {13, 23},
                {15, 20}, {14, 26}, {14, 44}, {17, 40}, {17, 47}, {24, 17}, {21, 21}, {25, 22}, {31, 27}, {22, 29},
                {19, 35}, {14, 50}, {10, 57}, {7, 63}, {-2, 77}, {-4, 82}, {-3, 94}, {9, 69}, {-12, 109}, {36, -35},
                {36, -34}, {32, -26}, {37, -30}, {44, -32}, {34, -18}, {34, -15}, {40, -15}, {33, -7}, {35, -5}, {33, 0},
                {38, 2}, {33, 13}, {23, 35}, {13, 58}, {15, 6}, {6, 19}, {7, 16}, {12, 14}, {18, 13}, {13, 11},
                {13, 15}, {15, 16}, {12, 23}, {13, 23}, {15, 20}, {14, 26}, {14, 44}, {17, 40}, {17, 47}, {24, 17},
                {21, 21}, {25, 22}, {31, 27}, {22, 29}, {19, 35}, {14, 50}, {10, 57}, {7, 63}, {-2, 77}, {-4, 82},
                {-3, 94}, {9, 69}, {-12, 109}, {36, -35}, {36, -34}, {32, -26}, {37, -30}, {44, -32}, {34, -18}, {34, -15},
                {40, -15}, {33, -7}, {35, -5}, {33, 0}, {38, 2}, {33, 13}, {23, 35}, {13, 58}
            },
            {
                {14, 11}, {11, 14}, {9, 11}, {18, 11}, {21, 9}, {23, -2}, {32, -15}, {32, -15}, {34, -21}, {39, -23},
                {42, -33}, {41, -31}, {46, -28}, {38, -12}, {21, 29}, {45, -24}, {53, -45}, {48, -26}, {65, -43}, {43, -19},
                {39, -10}, {30, 9}, {18, 26}, {20, 27}, {0, 57}, {-14, 82}, {-5, 75}, {-19, 97}, {-35, 125}, {27, 0},
                {28, 0}, {31, -4}, {27, 6}, {34, 8}, {30, 10}, {24, 22}, {33, 19}, {22, 32}, {26, 31}, {21, 41},
                {26, 44}, {23, 47}, {16, 65}, {14, 71}, {14, 11}, {11, 14}, {9, 11}, {18, 11}, {21, 9}, {23, -2},
                {32, -15}, {32, -15}, {34, -21}, {39, -23}, {42, -33}, {41, -31}, {46, -28}, {38, -12}, {21, 29}, {45, -24},
                {53, -45}, {48, -26}, {65, -43}, {43, -19}, {39, -10}, {30, 9}, {18, 26}, {20, 27}, {0, 57}, {-14, 82},
                {-5, 75}, {-19, 97}, {-35, 125}, {27, 0}, {28, 0}, {31, -4}, {27, 6}, {34, 8}, {30, 10}, {24, 22},
                {33, 19}, {22, 32}, {26, 31}, {21, 41}, {26, 44}, {23, 47}, {16, 65}, {14, 71}
            },
            {
                {19, -6}, {18, -6}, {14, 0}, {26, -12}, {31, -16}, {33, -25}, {33, -22}, {37, -28}, {39, -30}, {42, -30},
                {47, -42}, {45, -36}, {49, -34}, {41, -17}, {32, 9}, {69, -71}, {63, -63}, {66, -64}, {77, -74}, {54, -39},
                {52, -35}, {41, -10}, {36, 0}, {40, -1}, {30, 14}, {28, 26}, {23, 37}, {12, 55}, {11, 65}, {37, -33},
                {39, -36}, {40, -37}, {38, -30}, {46, -33}, {42, -30}, {40, -24}, {49, -29}, {38, -12}, {40, -10}, {38, -3},
                {46, -5}, {31, 20}, {29, 30}, {25, 44}, {19, -6}, {18, -6}, {14, 0}, {26, -12}, {31, -16}, {33, -25},
                {33, -22}, {37, -28}, {39, -30}, {42, -30}, {47, -42}, {45, -36}, {49, -34}, {41, -17}, {32, 9}, {69, -71},
                {63, -63}, {66, -64}, {77, -74}, {54, -39}, {52, -35}, {41, -10}, {36, 0}, {40, -1}, {30, 14}, {28, 26},
                {23, 37}, {12, 55}, {11, 65}, {37, -33}, {39, -36}, {40, -37}, {38, -30}, {46, -33}, {42, -30}, {40, -24},
                {49, -29}, {38, -12}, {40, -10}, {38, -3}, {46, -5}, {31, 20}, {29, 30}, {25, 44}
            },
            {
                {17, -13}, {16, -9}, {17, -12}, {27, -21}, {37, -30}, {41, -40}, {42, -41}, {48, -47}, {39, -32}, {46, -40},
                {52, -51}, {46, -41}, {52, -39}, {43, -19}, {32, 11}, {61, -55}, {56, -46}, {62, -50}, {81, -67}, {45, -20},
                {35, -2}, {28, 15}, {34, 1}, {39, 1}, {30, 17}, {20, 38}, {18, 45}, {15, 54}, {0, 79}, {36, -16},
                {37, -14}, {37, -17}, {32, 1}, {34, 15}, {29, 15}, {24, 25}, {34, 22}, {31, 16}, {35, 18}, {31, 28},
                {33, 41}, {36, 28}, {27, 47}, {21, 62}, {17, -13}, {16, -9}, {17, -12}, {27, -21}, {37, -30}, {41, -40},
                {42, -41}, {48, -47}, {39, -32}, {46, -40}, {52, -51}, {46, -41}, {52, -39}, {43, -19}, {32, 11}, {61, -55},
                {56, -46}, {62, -50}, {81, -67}, {45, -20}, {35, -2}, {28, 15}, {34, 1}, {39, 1}, {30, 17}, {20, 38},
                {18, 45}, {15, 54}, {0, 79}, {36, -16}, {37, -14}, {37, -17}, {32, 1}, {34, 15}, {29, 15}, {24, 25},
                {34, 22}, {31, 16}, {35, 18}, {31, 28}, {33, 41}, {36, 28}, {27, 47}, {21, 62}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I || slice_type == H264_SLIECE_TYPE_SI)
        {
            m = mn[0][ctxIdx - 864][0];
            n = mn[0][ctxIdx - 864][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 864][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 864][1];
        }
    }
    
    //Table 9-32 – Values of variables m and n for ctxIdx from 952 to 1011
    else if (ctxIdx >= 952 && ctxIdx <= 1011)
    {
        const int8_t mn[4][60][2] = 
        {
            {
                {-3, 71}, {-6, 42}, {-5, 50}, {-3, 54}, {-2, 62}, {0, 58}, {1, 63}, {-2, 72}, {-1, 74}, {-9, 91},
                {-5, 67}, {-5, 27}, {-3, 39}, {-2, 44}, {0, 46}, {-16, 64}, {-8, 68}, {-10, 78}, {-6, 77}, {-10, 86},
                {-12, 92}, {-15, 55}, {-10, 60}, {-6, 62}, {-4, 65}, {-12, 73}, {-8, 76}, {-7, 80}, {-9, 88}, {-17, 110},
                {-3, 71}, {-6, 42}, {-5, 50}, {-3, 54}, {-2, 62}, {0, 58}, {1, 63}, {-2, 72}, {-1, 74}, {-9, 91},
                {-5, 67}, {-5, 27}, {-3, 39}, {-2, 44}, {0, 46}, {-16, 64}, {-8, 68}, {-10, 78}, {-6, 77}, {-10, 86},
                {-12, 92}, {-15, 55}, {-10, 60}, {-6, 62}, {-4, 65}, {-12, 73}, {-8, 76}, {-7, 80}, {-9, 88}, {-17, 110}
            },
            {
                {-6, 76}, {-2, 44}, {0, 45}, {0, 52}, {-3, 64}, {-2, 59}, {-4, 70}, {-4, 75}, {-8, 82}, {-17, 102},
                {-9, 77}, {3, 24}, {0, 42}, {0, 48}, {0, 55}, {-6, 59}, {-7, 71}, {-12, 83}, {-11, 87}, {-30, 119},
                {1, 58}, {-3, 29}, {-1, 36}, {1, 38}, {2, 43}, {-6, 55}, {0, 58}, {0, 64}, {-3, 74}, {-10, 90},
                {-6, 76}, {-2, 44}, {0, 45}, {0, 52}, {-3, 64}, {-2, 59}, {-4, 70}, {-4, 75}, {-8, 82}, {-17, 102},
                {-9, 77}, {3, 24}, {0, 42}, {0, 48}, {0, 55}, {-6, 59}, {-7, 71}, {-12, 83}, {-11, 87}, {-30, 119},
                {1, 58}, {-3, 29}, {-1, 36}, {1, 38}, {2, 43}, {-6, 55}, {0, 58}, {0, 64}, {-3, 74}, {-10, 90}
            },
            {
                {-23, 112}, {-15, 71}, {-7, 61}, {0, 53}, {-5, 66}, {-11, 77}, {-9, 80}, {-9, 84}, {-10, 87}, {-34, 127},
                {-21, 101}, {-3, 39}, {-5, 53}, {-7, 61}, {-11, 75}, {-15, 77}, {-17, 91}, {-25, 107}, {-25, 111}, {-28, 122},
                {-11, 76}, {-10, 44}, {-10, 52}, {-10, 57}, {-9, 58}, {-16, 72}, {-7, 69}, {-4, 69}, {-5, 74}, {-9, 86},
                {-23, 112}, {-15, 71}, {-7, 61}, {0, 53}, {-5, 66}, {-11, 77}, {-9, 80}, {-9, 84}, {-10, 87}, {-34, 127},
                {-21, 101}, {-3, 39}, {-5, 53}, {-7, 61}, {-11, 75}, {-15, 77}, {-17, 91}, {-25, 107}, {-25, 111}, {-28, 122},
                {-11, 76}, {-10, 44}, {-10, 52}, {-10, 57}, {-9, 58}, {-16, 72}, {-7, 69}, {-4, 69}, {-5, 74}, {-9, 86}
            },
            {
                {-24, 115}, {-22, 82}, {-9, 62}, {0, 53}, {0, 59}, {-14, 85}, {-13, 89}, {-13, 94}, {-11, 92}, {-29, 127},
                {-21, 100}, {-14, 57}, {-12, 67}, {-11, 71}, {-10, 77}, {-21, 85}, {-16, 88}, {-23, 104}, {-15, 98}, {-37, 127},
                {-10, 82}, {-8, 48}, {-8, 61}, {-8, 66}, {-7, 70}, {-14, 75}, {-10, 79}, {-9, 83}, {-12, 92}, {-18, 108},
                {-24, 115}, {-22, 82}, {-9, 62}, {0, 53}, {0, 59}, {-14, 85}, {-13, 89}, {-13, 94}, {-11, 92}, {-29, 127},
                {-21, 100}, {-14, 57}, {-12, 67}, {-11, 71}, {-10, 77}, {-21, 85}, {-16, 88}, {-23, 104}, {-15, 98}, {-37, 127},
                {-10, 82}, {-8, 48}, {-8, 61}, {-8, 66}, {-7, 70}, {-14, 75}, {-10, 79}, {-9, 83}, {-12, 92}, {-18, 108}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I || slice_type == H264_SLIECE_TYPE_SI)
        {
            m = mn[0][ctxIdx - 952][0];
            n = mn[0][ctxIdx - 952][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 952][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 952][1];
        }
    }
    
    //Table 9-33 – Values of variables m and n for ctxIdx from 1012 to 1023
    else if (ctxIdx >= 1012 && ctxIdx <= 1023)
    {
        const int8_t mn[4][12][2] = 
        {
            {
                {-3, 70}, {-8, 93}, {-10, 90}, {-30, 127}, {-3, 70}, {-8, 93}, {-10, 90}, {-30, 127}, {-3, 70}, {-8, 93},
                {-10, 90}, {-30, 127}
            },
            {
                {-3, 74}, {-9, 92}, {-8, 87}, {-23, 126}, {-3, 74}, {-9, 92}, {-8, 87}, {-23, 126}, {-3, 74}, {-9, 92},
               {-8, 87}, {-23, 126}
            },
            {
                {-2, 73}, {-12, 104}, {-9, 91}, {-31, 127}, {-2, 73}, {-12, 104}, {-9, 91}, {-31, 127}, {-2, 73}, {-12, 104},
                {-9, 91}, {-31, 127}
            },
            {
                {-5, 79}, {-11, 104}, {-11, 91}, {-30, 127}, {-5, 79}, {-11, 104}, {-11, 91}, {-30, 127}, {-5, 79}, {-11, 104},
                {-11, 91}, {-30, 127}
            }
        };
        
        if (slice_type == H264_SLIECE_TYPE_I || slice_type == H264_SLIECE_TYPE_SI)
        {
            m = mn[0][ctxIdx - 1012][0];
            n = mn[0][ctxIdx - 1012][1];
        }
        else
        {
            m = mn[cabac_init_idc + 1][ctxIdx - 1012][0];
            n = mn[cabac_init_idc + 1][ctxIdx - 1012][1];
        }
    }
    else if (ctxIdx == 276)
    {
        return -1; //ctxIdx = 276 is assigned to the binIdx of mb_type indicating the I_PCM mode.
    }
    else
    {
        RETURN_IF_FAILED(-1, -1);
    }

    return 0;
}


//---------------------------------------------------
//9.3.1.1 Initialisation process for context variables
int CH264Cabac::Initialisation_process_for_context_variables(H264_SLIECE_TYPE slice_type, int32_t cabac_init_idc, int32_t SliceQPY)
{
    int ret = 0;
    
    int32_t m = 0;
    int32_t n = 0;

    //The possible values of the context index ctxIdx are in the range 0 to 1023, inclusive.
    for (int32_t ctxIdx = 0; ctxIdx < 1024; ++ctxIdx)
    {
        ret = get_m_and_n(ctxIdx, slice_type, cabac_init_idc, m, n);
        if (ret == 0)
        {
            int32_t preCtxState = CLIP3( 1, 126, ( ( m * CLIP3( 0, 51, SliceQPY ) ) >> 4 ) + n );

            if ( preCtxState <= 63 )
            {
                m_pStateIdxs[ctxIdx] = 63 - preCtxState;
                m_valMPSs[ctxIdx] = 0;
            }
            else
            {
                m_pStateIdxs[ctxIdx] = preCtxState - 64;
                m_valMPSs[ctxIdx] = 1;
            }
        }
    }

    return 0;
}


//9.3.1.2 Initialisation process for the arithmetic decoding engine
//This process is invoked before decoding the first macroblock of a slice or after 
//the decoding of any pcm_alignment_zero_bit and all pcm_sample_luma and 
//pcm_sample_chroma data for a macroblock of type I_PCM.
int CH264Cabac::Initialisation_process_for_the_arithmetic_decoding_engine(CBitstream &bs)
{
    m_codIRange = 510; //510 = 0x01FE

    m_codIOffset = bs.readBits(9); //read_bits(9);

    return 0;
}


//9.3.3.1.1.1 Derivation process of ctxIdxInc for the syntax element mb_skip_flag
int CH264Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_skip_flag(CH264PictureBase &picture, int32_t _CurrMbAddr, int32_t &ctxIdxInc)
{
    int ret = 0;

    //When MbaffFrameFlag is equal to 1 and mb_field_decoding_flag has not been decoded (yet) for the current macroblock pair 
    //with top macroblock address 2 * ( CurrMbAddr / 2 ), the inference rule for the syntax element mb_field_decoding_flag as 
    //specified in clause 7.4.4 is applied.

    int32_t mbAddrA = 0;
    int32_t mbAddrB = 0;

    int32_t isChroma = 0;

    //6.4.11.1 Derivation process for neighbouring macroblocks
    ret = picture.Derivation_process_for_neighbouring_macroblocks(picture.m_h264_slice_header.MbaffFrameFlag, _CurrMbAddr, mbAddrA, mbAddrB, isChroma);
    RETURN_IF_FAILED(ret != 0, ret);

    int32_t condTermFlagA = 0;
    int32_t condTermFlagB = 0;

    //---------------------------
    if (mbAddrA < 0
        || picture.m_mbs[mbAddrA].mb_skip_flag == 1
       )
    {
        condTermFlagA = 0;
    }
    else
    {
        condTermFlagA = 1;
    }

    //---------------------------
    if (mbAddrB < 0
        || picture.m_mbs[mbAddrB].mb_skip_flag == 1
       )
    {
        condTermFlagB = 0;
    }
    else
    {
        condTermFlagB = 1;
    }

    ctxIdxInc = condTermFlagA + condTermFlagB;
    
    return 0;
}


//9.3.3.1.1.2 Derivation process of ctxIdxInc for the syntax element mb_field_decoding_flag
int CH264Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_field_decoding_flag(CH264PictureBase &picture, int32_t &ctxIdxInc)
{
    int ret = 0;
    
    int32_t mbAddrA = 0;
    int32_t mbAddrB = 0;
    int32_t mbAddrC = 0;
    int32_t mbAddrD = 0;

    //6.4.10 Derivation process for neighbouring macroblock addresses and their availability in MBAFF frames
    ret = picture.Derivation_process_for_neighbouring_macroblock_addresses_and_their_availability_in_MBAFF_frames(picture.CurrMbAddr, mbAddrA, mbAddrB, mbAddrC, mbAddrD);
    RETURN_IF_FAILED(ret != 0, -1);
    
    //When both macroblocks mbAddrN and mbAddrN + 1 have mb_type equal to P_Skip or B_Skip, the inference rule 
    //for the syntax element mb_field_decoding_flag as specified in clause 7.4.4 is applied for the macroblock mbAddrN.
    
    //------------------------
    int32_t condTermFlagA = 0;
    int32_t condTermFlagB = 0;

    //---------A--------------
    if (mbAddrA < 0 
        || picture.m_mbs[mbAddrA].mb_field_decoding_flag == 0
       )
    {
        condTermFlagA = 0;
    }
    else
    {
        condTermFlagA = 1;
    }
    
    //---------B--------------
    if (mbAddrB < 0 
        || picture.m_mbs[mbAddrB].mb_field_decoding_flag == 0
       )
    {
        condTermFlagB = 0;
    }
    else
    {
        condTermFlagB = 1;
    }

    //---------------
    ctxIdxInc = condTermFlagA + condTermFlagB;

    return 0;
}


//9.3.3.1.1.3 Derivation process of ctxIdxInc for the syntax element mb_type
int CH264Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_type(CH264PictureBase &picture, int32_t ctxIdxOffset, int32_t &ctxIdxInc)
{
    int ret = 0;

    int32_t mbAddrA = 0;
    int32_t mbAddrB = 0;
    int32_t isChroma = 0;

    //6.4.11.1 Derivation process for neighbouring macroblocks
    ret = picture.Derivation_process_for_neighbouring_macroblocks(picture.m_h264_slice_header.MbaffFrameFlag, picture.CurrMbAddr, mbAddrA, mbAddrB, isChroma);
    RETURN_IF_FAILED(ret != 0, ret);

    int32_t condTermFlagA = 0;
    int32_t condTermFlagB = 0;

    //---------------------------
    if (mbAddrA < 0
        || (ctxIdxOffset == 0 && picture.m_mbs[mbAddrA].m_name_of_mb_type == SI)
        || (ctxIdxOffset == 3 && picture.m_mbs[mbAddrA].m_name_of_mb_type == I_NxN)
        || (ctxIdxOffset == 27 && (picture.m_mbs[mbAddrA].m_name_of_mb_type == B_Skip || picture.m_mbs[mbAddrA].m_name_of_mb_type == B_Direct_16x16))
       )
    {
        condTermFlagA = 0;
    }
    else
    {
        condTermFlagA = 1;
    }

    //---------------------------
    if (mbAddrB < 0
        || (ctxIdxOffset == 0 && picture.m_mbs[mbAddrB].m_name_of_mb_type == SI)
        || (ctxIdxOffset == 3 && picture.m_mbs[mbAddrB].m_name_of_mb_type == I_NxN)
        || (ctxIdxOffset == 27 && (picture.m_mbs[mbAddrB].m_name_of_mb_type == B_Skip || picture.m_mbs[mbAddrB].m_name_of_mb_type == B_Direct_16x16))
       )
    {
        condTermFlagB = 0;
    }
    else
    {
        condTermFlagB = 1;
    }

    ctxIdxInc = condTermFlagA + condTermFlagB;

    return 0;
}


//9.3.3.1.1.4 Derivation process of ctxIdxInc for the syntax element coded_block_pattern
int CH264Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_pattern(CH264PictureBase &picture, int32_t binIdx, int32_t binValues, 
        int32_t ctxIdxOffset, int32_t &ctxIdxInc)
{
    int ret = 0;

    if (ctxIdxOffset == 73)
    {
        int32_t luma8x8BlkIdx = binIdx;
        int32_t mbAddrA = 0;
        int32_t mbAddrB = 0;
        int32_t luma8x8BlkIdxA = 0;
        int32_t luma8x8BlkIdxB = 0;
        int32_t isChroma = 0;

        //6.4.11.2 Derivation process for neighbouring 8x8 luma block
        ret = picture.Derivation_process_for_neighbouring_8x8_luma_block(luma8x8BlkIdx, mbAddrA, mbAddrB, luma8x8BlkIdxA, luma8x8BlkIdxB, isChroma);
        RETURN_IF_FAILED(ret != 0, -1);

        //----------------------------
        int32_t condTermFlagA = 0;
        int32_t condTermFlagB = 0;
        
        //int32_t bkA = (binValues >> (luma8x8BlkIdx - luma8x8BlkIdxA - 1));
        //int32_t bkB = (binValues >> (luma8x8BlkIdx - luma8x8BlkIdxB - 1));

        //-------A-----------
        if (mbAddrA < 0
            || picture.m_mbs[mbAddrA].m_name_of_mb_type == I_PCM
            || (mbAddrA != picture.CurrMbAddr
                && (picture.m_mbs[mbAddrA].m_name_of_mb_type != P_Skip && picture.m_mbs[mbAddrA].m_name_of_mb_type != B_Skip)
                && ((picture.m_mbs[mbAddrA].CodedBlockPatternLuma >> luma8x8BlkIdxA) & 1) != 0
               )
            || (mbAddrA == picture.CurrMbAddr
                && ((binValues >> luma8x8BlkIdxA) & 0x01) != 0  //FIXME: the prior decoded bin value bk of coded_block_pattern with k = luma8x8BlkIdxN is not equal to 0.
               )
           )
        {
            condTermFlagA = 0;
        }
        else
        {
            condTermFlagA = 1;
        }
        
        //-------B-----------
        if (mbAddrB < 0
            || picture.m_mbs[mbAddrB].m_name_of_mb_type == I_PCM
            || (mbAddrB != picture.CurrMbAddr
                && (picture.m_mbs[mbAddrB].m_name_of_mb_type != P_Skip && picture.m_mbs[mbAddrB].m_name_of_mb_type != B_Skip)
                && ((picture.m_mbs[mbAddrB].CodedBlockPatternLuma >> luma8x8BlkIdxB) & 1) != 0
               )
            || (mbAddrB == picture.CurrMbAddr
                && ((binValues >> luma8x8BlkIdxB) & 0x01) != 0  //FIXME: the prior decoded bin value bk of coded_block_pattern with k = luma8x8BlkIdxN is not equal to 0.
               )
           )
        {
            condTermFlagB = 0;
        }
        else
        {
            condTermFlagB = 1;
        }

        //----------------
        ctxIdxInc = condTermFlagA + 2 * condTermFlagB;
    }
    else //if (ctxIdxOffset == 77)
    {
        int32_t mbAddrA = 0;
        int32_t mbAddrB = 0;
        int32_t isChroma = 0;

        //6.4.11.1 Derivation process for neighbouring macroblocks
        ret = picture.Derivation_process_for_neighbouring_macroblocks(picture.m_h264_slice_header.MbaffFrameFlag, picture.CurrMbAddr, mbAddrA, mbAddrB, isChroma);
        RETURN_IF_FAILED(ret != 0, ret);

        int32_t condTermFlagA = 0;
        int32_t condTermFlagB = 0;

        //-----------A----------------
        if (mbAddrA >= 0 && picture.m_mbs[mbAddrA].m_name_of_mb_type == I_PCM)
        {
            condTermFlagA = 1;
        }
        else if (mbAddrA < 0
            || picture.m_mbs[mbAddrA].m_name_of_mb_type == P_Skip
            || picture.m_mbs[mbAddrA].m_name_of_mb_type == B_Skip
            || (binIdx == 0 && picture.m_mbs[mbAddrA].CodedBlockPatternChroma == 0)
            || (binIdx == 1 && picture.m_mbs[mbAddrA].CodedBlockPatternChroma != 2)
           )
        {
            condTermFlagA = 0;
        }
        else
        {
            condTermFlagA = 1;
        }
        
        //-----------B----------------
        if (mbAddrB >= 0 && picture.m_mbs[mbAddrB].m_name_of_mb_type == I_PCM)
        {
            condTermFlagB = 1;
        }
        else if (mbAddrB < 0
            || picture.m_mbs[mbAddrB].m_name_of_mb_type == P_Skip
            || picture.m_mbs[mbAddrB].m_name_of_mb_type == B_Skip
            || (binIdx == 0 && picture.m_mbs[mbAddrB].CodedBlockPatternChroma == 0)
            || (binIdx == 1 && picture.m_mbs[mbAddrB].CodedBlockPatternChroma != 2)
           )
        {
            condTermFlagB = 0;
        }
        else
        {
            condTermFlagB = 1;
        }

        //--------------
        ctxIdxInc = condTermFlagA + 2 * condTermFlagB + ( ( binIdx == 1 ) ? 4 : 0 );
    }
    
    return 0;
}


//9.3.3.1.1.5 Derivation process of ctxIdxInc for the syntax element mb_qp_delta
int CH264Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_qp_delta(CH264PictureBase &picture, int32_t &ctxIdxInc)
{
    //Let prevMbAddr be the macroblock address of the macroblock that precedes the current macroblock in decoding order.
    int32_t prevMbAddr = picture.CurrMbAddr - 1;

    //When the current macroblock is the first macroblock of a slice, prevMbAddr is marked as not available.
    
    int32_t FirstMbAddrOfSlice = picture.m_h264_slice_header.first_mb_in_slice * (1 + picture.m_h264_slice_header.MbaffFrameFlag);
    if (picture.CurrMbAddr == FirstMbAddrOfSlice)
    {
        prevMbAddr = -1;
    }

    if (prevMbAddr < 0 
        || picture.m_mbs[prevMbAddr].m_name_of_mb_type == P_Skip
        || picture.m_mbs[prevMbAddr].m_name_of_mb_type == B_Skip
        || picture.m_mbs[prevMbAddr].m_name_of_mb_type == I_PCM
        || (picture.m_mbs[prevMbAddr].m_mb_pred_mode != Intra_16x16
            && picture.m_mbs[prevMbAddr].CodedBlockPatternLuma == 0
            && picture.m_mbs[prevMbAddr].CodedBlockPatternChroma == 0
           )
        || picture.m_mbs[prevMbAddr].mb_qp_delta == 0
       )
    {
        ctxIdxInc = 0;
    }
    else
    {
        ctxIdxInc = 1;
    }

    return 0;
}


//9.3.3.1.1.6 Derivation process of ctxIdxInc for the syntax elements ref_idx_l0 and ref_idx_l1
int CH264Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_elements_ref_idx_l0_and_ref_idx_l1(CH264PictureBase &picture, int32_t is_ref_idx_10, 
        int32_t mbPartIdx, int32_t &ctxIdxInc)
{
    int ret = 0;
    
    CH264MacroBlock & mb = picture.m_mbs[picture.CurrMbAddr];

    H264_MB_TYPE currSubMbType = mb.m_name_of_sub_mb_type[ mbPartIdx ];
    int32_t isChroma = 0;

    int32_t subMbPartIdx = 0;

    int32_t mbAddrN_A= 0;
    int32_t mbPartIdxN_A = 0;
    int32_t subMbPartIdxN_A = 0;

    int32_t mbAddrN_B = 0;
    int32_t mbPartIdxN_B = 0;
    int32_t subMbPartIdxN_B = 0;

    //--------------------------------
    //6.4.2.1 Inverse macroblock partition scanning process
    int32_t MbPartWidth = mb.MbPartWidth;
    int32_t MbPartHeight = mb.MbPartHeight;
    int32_t SubMbPartWidth = mb.SubMbPartWidth[mbPartIdx];
    int32_t SubMbPartHeight = mb.SubMbPartHeight[mbPartIdx];

    int32_t x = InverseRasterScan( mbPartIdx, MbPartWidth, MbPartHeight, 16, 0 );
    int32_t y = InverseRasterScan( mbPartIdx, MbPartWidth, MbPartHeight, 16, 1 );

    //--------------------
    int32_t xS = 0;
    int32_t yS = 0;

    if (mb.m_name_of_mb_type == P_8x8 || mb.m_name_of_mb_type == P_8x8ref0 || mb.m_name_of_mb_type == B_8x8)
    {
        //6.4.2.2 Inverse sub-macroblock partition scanning process
        xS = InverseRasterScan( subMbPartIdx, SubMbPartWidth, SubMbPartHeight, 8, 0 );
        yS = InverseRasterScan( subMbPartIdx, SubMbPartWidth, SubMbPartHeight, 8, 1 );
        
        //Otherwise (mb_type is not equal to P_8x8, P_8x8ref0, or B_8x8),
        //xS = InverseRasterScan( subMbPartIdx, 4, 4, 8, 0 );
        //yS = InverseRasterScan( subMbPartIdx, 4, 4, 8, 1 );
    }
    else
    {
        xS = 0;
        yS = 0;
    }

    //6.4.11.7 Derivation process for neighbouring partitions
    ret = picture.Derivation_process_for_neighbouring_partitions(x + xS - 1, y + yS + 0, mbPartIdx, currSubMbType, subMbPartIdx, isChroma, mbAddrN_A, mbPartIdxN_A, subMbPartIdxN_A);
    RETURN_IF_FAILED(ret != 0, ret);
    
    ret = picture.Derivation_process_for_neighbouring_partitions(x + xS + 0, y + yS - 1, mbPartIdx, currSubMbType, subMbPartIdx, isChroma, mbAddrN_B, mbPartIdxN_B, subMbPartIdxN_B);
    RETURN_IF_FAILED(ret != 0, ret);
    
    //--------------------------------
    int32_t refIdxZeroFlagA = 0;
    int32_t refIdxZeroFlagB = 0;
    int32_t predModeEqualFlagA = 0;
    int32_t predModeEqualFlagB = 0;
    int32_t condTermFlagA = 0;
    int32_t condTermFlagB = 0;
    
    //------------A--------------------
    if (mbAddrN_A >= 0)
    {
        if (mb.MbaffFrameFlag == 1
            && mb.mb_field_decoding_flag == 0
            && picture.m_mbs[mbAddrN_A].mb_field_decoding_flag == 1
            )
        {
            if (is_ref_idx_10 == 1)
            {
                refIdxZeroFlagA = ( picture.m_mbs[mbAddrN_A].ref_idx_l0[ mbPartIdxN_A ] > 1 ) ? 0 : 1 ;
            }
            else //if (is_ref_idx_10 == 0)
            {
                refIdxZeroFlagA = ( picture.m_mbs[mbAddrN_A].ref_idx_l1[ mbPartIdxN_A ] > 1 ) ? 0 : 1 ;
            }
        }
        else
        {
            if (is_ref_idx_10 == 1)
            {
                refIdxZeroFlagA = ( picture.m_mbs[mbAddrN_A].ref_idx_l0[ mbPartIdxN_A ] > 0 ) ? 0 : 1 ;
            }
            else //if (is_ref_idx_10 == 0)
            {
                refIdxZeroFlagA = ( picture.m_mbs[mbAddrN_A].ref_idx_l1[ mbPartIdxN_A ] > 0 ) ? 0 : 1 ;
            }
        }
        
        if (picture.m_mbs[mbAddrN_A].m_name_of_mb_type == B_Direct_16x16 || picture.m_mbs[mbAddrN_A].m_name_of_mb_type == B_Skip)
        {
            predModeEqualFlagA = 0;
        }
        else if (picture.m_mbs[mbAddrN_A].m_name_of_mb_type == P_8x8 || picture.m_mbs[mbAddrN_A].m_name_of_mb_type == B_8x8)
        {
            int32_t NumSubMbPart = 0;
            H264_MB_PART_PRED_MODE SubMbPredMode = MB_PRED_MODE_NA;
            int32_t SubMbPartWidth = 0;
            int32_t SubMbPartHeight = 0;

            ret = CH264MacroBlock::SubMbPredModeFunc(picture.m_h264_slice_header.slice_type, picture.m_mbs[mbAddrN_A].sub_mb_type[ mbPartIdxN_A ], 
                    NumSubMbPart, SubMbPredMode, SubMbPartWidth, SubMbPartHeight);
            RETURN_IF_FAILED(ret != 0, ret);

            if (((is_ref_idx_10 == 1 && SubMbPredMode != Pred_L0) || (is_ref_idx_10 == 0 && SubMbPredMode != Pred_L1)) && SubMbPredMode != BiPred)
            {
                predModeEqualFlagA = 0;
            }
            else
            {
                predModeEqualFlagA = 1;
            }
        }
        else
        {
            H264_MB_PART_PRED_MODE mb_pred_mode = MB_PRED_MODE_NA;

            ret = CH264MacroBlock::MbPartPredMode2(picture.m_mbs[mbAddrN_A].m_name_of_mb_type, mbPartIdxN_A, picture.m_mbs[mbAddrN_A].transform_size_8x8_flag, mb_pred_mode);
            RETURN_IF_FAILED(ret != 0, ret);
            
            if (((is_ref_idx_10 == 1 && mb_pred_mode != Pred_L0) || (is_ref_idx_10 == 0 && mb_pred_mode != Pred_L1)) && mb_pred_mode != BiPred)
            {
                predModeEqualFlagA = 0;
            }
            else
            {
                predModeEqualFlagA = 1;
            }
        }
    }
    else //if (mbAddrN_A < 0) //FIXME:
    {
        predModeEqualFlagA = 0;
    }
    
    if (mbAddrN_A < 0
        || (picture.m_mbs[mbAddrN_A].m_name_of_mb_type == P_Skip || picture.m_mbs[mbAddrN_A].m_name_of_mb_type == B_Skip)
        || IS_INTRA_Prediction_Mode(picture.m_mbs[mbAddrN_A].m_mb_pred_mode)
        || predModeEqualFlagA == 0
        || refIdxZeroFlagA == 1
       )
    {
        condTermFlagA = 0;
    }
    else
    {
        condTermFlagA = 1;
    }
    
    //------------B--------------------
    if (mbAddrN_B >= 0)
    {
        if (mb.MbaffFrameFlag == 1
            && mb.mb_field_decoding_flag == 0
            && picture.m_mbs[mbAddrN_B].mb_field_decoding_flag == 1
            )
        {
            if (is_ref_idx_10 == 1)
            {
                refIdxZeroFlagB = ( picture.m_mbs[mbAddrN_B].ref_idx_l0[ mbPartIdxN_B ] > 1 ) ? 0 : 1 ;
            }
            else //if (is_ref_idx_10 == 0)
            {
                refIdxZeroFlagB = ( picture.m_mbs[mbAddrN_B].ref_idx_l1[ mbPartIdxN_B ] > 1 ) ? 0 : 1 ;
            }
        }
        else
        {
            if (is_ref_idx_10 == 1)
            {
                refIdxZeroFlagB = ( picture.m_mbs[mbAddrN_B].ref_idx_l0[ mbPartIdxN_B ] > 0 ) ? 0 : 1 ;
            }
            else //if (is_ref_idx_10 == 0)
            {
                refIdxZeroFlagB = ( picture.m_mbs[mbAddrN_B].ref_idx_l1[ mbPartIdxN_B ] > 0 ) ? 0 : 1 ;
            }
        }
        
        if (picture.m_mbs[mbAddrN_B].m_name_of_mb_type == B_Direct_16x16 || picture.m_mbs[mbAddrN_B].m_name_of_mb_type == B_Skip)
        {
            predModeEqualFlagB = 0;
        }
        else if (picture.m_mbs[mbAddrN_B].m_name_of_mb_type == P_8x8 || picture.m_mbs[mbAddrN_B].m_name_of_mb_type == B_8x8)
        {
            int32_t NumSubMbPart = 0;
            H264_MB_PART_PRED_MODE SubMbPredMode = MB_PRED_MODE_NA;
            int32_t SubMbPartWidth = 0;
            int32_t SubMbPartHeight = 0;

            ret = CH264MacroBlock::SubMbPredModeFunc(picture.m_h264_slice_header.slice_type, picture.m_mbs[mbAddrN_B].sub_mb_type[ mbPartIdxN_B ], 
                    NumSubMbPart, SubMbPredMode, SubMbPartWidth, SubMbPartHeight);
            RETURN_IF_FAILED(ret != 0, ret);

            if (((is_ref_idx_10 == 1 && SubMbPredMode != Pred_L0) || (is_ref_idx_10 == 0 && SubMbPredMode != Pred_L1)) && SubMbPredMode != BiPred)
            {
                predModeEqualFlagB = 0;
            }
            else
            {
                predModeEqualFlagB = 1;
            }
        }
        else
        {
            H264_MB_PART_PRED_MODE mb_pred_mode = MB_PRED_MODE_NA;

            ret = CH264MacroBlock::MbPartPredMode2(picture.m_mbs[mbAddrN_B].m_name_of_mb_type, mbPartIdxN_B, picture.m_mbs[mbAddrN_B].transform_size_8x8_flag, mb_pred_mode);
            RETURN_IF_FAILED(ret != 0, ret);
            
            if (((is_ref_idx_10 == 1 && mb_pred_mode != Pred_L0) || (is_ref_idx_10 == 0 && mb_pred_mode != Pred_L1)) && mb_pred_mode != BiPred)
            {
                predModeEqualFlagB = 0;
            }
            else
            {
                predModeEqualFlagB = 1;
            }
        }
    }
    else //if (mbAddrN_B < 0) //FIXME:
    {
        predModeEqualFlagB = 0;
    }
    
    if (mbAddrN_B < 0
        || (picture.m_mbs[mbAddrN_B].m_name_of_mb_type == P_Skip || picture.m_mbs[mbAddrN_B].m_name_of_mb_type == B_Skip)
        || IS_INTRA_Prediction_Mode(picture.m_mbs[mbAddrN_B].m_mb_pred_mode)
        || predModeEqualFlagB == 0
        || refIdxZeroFlagB == 1
       )
    {
        condTermFlagB = 0;
    }
    else
    {
        condTermFlagB = 1;
    }

    //-------------------
    ctxIdxInc = condTermFlagA + 2 * condTermFlagB;

    return 0;
}


//9.3.3.1.1.7 Derivation process of ctxIdxInc for the syntax elements mvd_l0 and mvd_l1
int CH264Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_elements_mvd_l0_and_mvd_l1(CH264PictureBase &picture, int32_t is_mvd_10, int32_t mbPartIdx, int32_t subMbPartIdx, 
                int32_t isChroma, int32_t ctxIdxOffset, int32_t &ctxIdxInc)
{
    int ret = 0;
    
    CH264MacroBlock & mb = picture.m_mbs[picture.CurrMbAddr];

    H264_MB_TYPE currSubMbType = mb.m_name_of_sub_mb_type[ mbPartIdx ];
    
    int32_t mbAddrN_A= 0;
    int32_t mbPartIdxN_A = 0;
    int32_t subMbPartIdxN_A = 0;

    int32_t mbAddrN_B = 0;
    int32_t mbPartIdxN_B = 0;
    int32_t subMbPartIdxN_B = 0;

    //--------------------------------
    //6.4.2.1 Inverse macroblock partition scanning process
    int32_t MbPartWidth = mb.MbPartWidth;
    int32_t MbPartHeight = mb.MbPartHeight;
    int32_t SubMbPartWidth = mb.SubMbPartWidth[mbPartIdx];
    int32_t SubMbPartHeight = mb.SubMbPartHeight[mbPartIdx];

    int32_t x = InverseRasterScan( mbPartIdx, MbPartWidth, MbPartHeight, 16, 0 );
    int32_t y = InverseRasterScan( mbPartIdx, MbPartWidth, MbPartHeight, 16, 1 );

    //--------------------
    int32_t xS = 0;
    int32_t yS = 0;

    if (mb.m_name_of_mb_type == P_8x8 || mb.m_name_of_mb_type == P_8x8ref0 || mb.m_name_of_mb_type == B_8x8)
    {
        //6.4.2.2 Inverse sub-macroblock partition scanning process
        xS = InverseRasterScan( subMbPartIdx, SubMbPartWidth, SubMbPartHeight, 8, 0 );
        yS = InverseRasterScan( subMbPartIdx, SubMbPartWidth, SubMbPartHeight, 8, 1 );
        
        //Otherwise (mb_type is not equal to P_8x8, P_8x8ref0, or B_8x8),
        //xS = InverseRasterScan( subMbPartIdx, 4, 4, 8, 0 );
        //yS = InverseRasterScan( subMbPartIdx, 4, 4, 8, 1 );
    }
    else
    {
        xS = 0;
        yS = 0;
    }

    //6.4.11.7 Derivation process for neighbouring partitions
    ret = picture.Derivation_process_for_neighbouring_partitions(x + xS - 1, y + yS + 0, mbPartIdx, currSubMbType, subMbPartIdx, isChroma, mbAddrN_A, mbPartIdxN_A, subMbPartIdxN_A);
    RETURN_IF_FAILED(ret != 0, ret);
    
    ret = picture.Derivation_process_for_neighbouring_partitions(x + xS + 0, y + yS - 1, mbPartIdx, currSubMbType, subMbPartIdx, isChroma, mbAddrN_B, mbPartIdxN_B, subMbPartIdxN_B);
    RETURN_IF_FAILED(ret != 0, ret);
    
    //--------------------
    int32_t compIdx = 0;

    if (ctxIdxOffset == 40)
    {
        compIdx = 0;
    }
    else //if (ctxIdxOffset == 47)
    {
        compIdx = 1;
    }

    int32_t predModeEqualFlagA = 0;
    int32_t predModeEqualFlagB = 0;
    int32_t absMvdCompA = 0;
    int32_t absMvdCompB = 0;
    
    //------------------A-------------------------
    if (mbAddrN_A >= 0 && (picture.m_mbs[mbAddrN_A].m_name_of_mb_type == B_Direct_16x16 || picture.m_mbs[mbAddrN_A].m_name_of_mb_type == B_Skip))
    {
        predModeEqualFlagA = 0;
    }
    else if (mbAddrN_A >= 0 && (picture.m_mbs[mbAddrN_A].m_name_of_mb_type == P_8x8 || picture.m_mbs[mbAddrN_A].m_name_of_mb_type == B_8x8))
    {
        int32_t NumSubMbPart = 0;
        H264_MB_PART_PRED_MODE SubMbPredMode = MB_PRED_MODE_NA;
        int32_t SubMbPartWidth = 0;
        int32_t SubMbPartHeight = 0;

        ret = CH264MacroBlock::SubMbPredModeFunc(picture.m_h264_slice_header.slice_type, picture.m_mbs[mbAddrN_A].sub_mb_type[ mbPartIdxN_A ], 
                NumSubMbPart, SubMbPredMode, SubMbPartWidth, SubMbPartHeight);
        RETURN_IF_FAILED(ret != 0, ret);

        if (((is_mvd_10 == 1 && SubMbPredMode != Pred_L0) || (is_mvd_10 == 0 && SubMbPredMode != Pred_L1)) && SubMbPredMode != BiPred)
        {
            predModeEqualFlagA = 0;
        }
        else
        {
            predModeEqualFlagA = 1;
        }
    }
    else if (mbAddrN_A >= 0)
    {
        H264_MB_PART_PRED_MODE mb_pred_mode = MB_PRED_MODE_NA;

        ret = CH264MacroBlock::MbPartPredMode2(picture.m_mbs[mbAddrN_A].m_name_of_mb_type, mbPartIdxN_A, picture.m_mbs[mbAddrN_A].transform_size_8x8_flag, mb_pred_mode);
        RETURN_IF_FAILED(ret != 0, ret);
        
        if (((is_mvd_10 == 1 && mb_pred_mode != Pred_L0) || (is_mvd_10 == 0 && mb_pred_mode != Pred_L1)) && mb_pred_mode != BiPred)
        {
            predModeEqualFlagA = 0;
        }
        else
        {
            predModeEqualFlagA = 1;
        }
    }
    else //if (mbAddrN_A < 0)
    {
        predModeEqualFlagA = 0; //FIXME:
    }

    if (mbAddrN_A < 0
        || (picture.m_mbs[mbAddrN_A].m_name_of_mb_type == P_Skip || picture.m_mbs[mbAddrN_A].m_name_of_mb_type == B_Skip)
        || IS_INTRA_Prediction_Mode(picture.m_mbs[mbAddrN_A].m_mb_pred_mode)
        || predModeEqualFlagA == 0
       )
    {
        absMvdCompA = 0;
    }
    else
    {
        //If compIdx is equal to 1, MbaffFrameFlag is equal to 1, the current macroblock is a frame macroblock, and the macroblock mbAddrN is a field macroblock,
        if (compIdx == 1
            && mb.MbaffFrameFlag == 1
            && mb.mb_field_decoding_flag == 0
            && picture.m_mbs[mbAddrN_A].mb_field_decoding_flag == 1
            )
        {
            if (is_mvd_10 == 1)
            {
                absMvdCompA = ABS( picture.m_mbs[mbAddrN_A].mvd_l0[ mbPartIdxN_A ][ subMbPartIdxN_A ][ compIdx ] ) * 2;
            }
            else //if (is_mvd_10 == 0)
            {
                absMvdCompA = ABS( picture.m_mbs[mbAddrN_A].mvd_l1[ mbPartIdxN_A ][ subMbPartIdxN_A ][ compIdx ] ) * 2;
            }
        }
        else if (compIdx == 1
            && mb.MbaffFrameFlag == 1
            && mb.mb_field_decoding_flag == 1
            && picture.m_mbs[mbAddrN_A].mb_field_decoding_flag == 0
            )
        {
            if (is_mvd_10 == 1)
            {
                absMvdCompA = ABS( picture.m_mbs[mbAddrN_A].mvd_l0[ mbPartIdxN_A ][ subMbPartIdxN_A ][ compIdx ] ) / 2;
            }
            else //if (is_mvd_10 == 0)
            {
                absMvdCompA = ABS( picture.m_mbs[mbAddrN_A].mvd_l1[ mbPartIdxN_A ][ subMbPartIdxN_A ][ compIdx ] ) / 2;
            }
        }
        else
        {
            if (is_mvd_10 == 1)
            {
                absMvdCompA = ABS( picture.m_mbs[mbAddrN_A].mvd_l0[ mbPartIdxN_A ][ subMbPartIdxN_A ][ compIdx ] );
            }
            else //if (is_mvd_10 == 0)
            {
                absMvdCompA = ABS( picture.m_mbs[mbAddrN_A].mvd_l1[ mbPartIdxN_A ][ subMbPartIdxN_A ][ compIdx ] );
            }
        }
    }
    
    //------------------B-------------------------
    if (mbAddrN_B >= 0 && (picture.m_mbs[mbAddrN_B].m_name_of_mb_type == B_Direct_16x16 || picture.m_mbs[mbAddrN_B].m_name_of_mb_type == B_Skip))
    {
        predModeEqualFlagB = 0;
    }
    else if (mbAddrN_B >= 0 && (picture.m_mbs[mbAddrN_B].m_name_of_mb_type == P_8x8 || picture.m_mbs[mbAddrN_B].m_name_of_mb_type == B_8x8))
    {
        int32_t NumSubMbPart = 0;
        H264_MB_PART_PRED_MODE SubMbPredMode = MB_PRED_MODE_NA;
        int32_t SubMbPartWidth = 0;
        int32_t SubMbPartHeight = 0;

        ret = CH264MacroBlock::SubMbPredModeFunc(picture.m_h264_slice_header.slice_type, picture.m_mbs[mbAddrN_B].sub_mb_type[ mbPartIdxN_B ], 
                NumSubMbPart, SubMbPredMode, SubMbPartWidth, SubMbPartHeight);
        RETURN_IF_FAILED(ret != 0, ret);

        if (((is_mvd_10 == 1 && SubMbPredMode != Pred_L0) || (is_mvd_10 == 0 && SubMbPredMode != Pred_L1)) && SubMbPredMode != BiPred)
        {
            predModeEqualFlagB = 0;
        }
        else
        {
            predModeEqualFlagB = 1;
        }
    }
    else if (mbAddrN_B >= 0)
    {
        H264_MB_PART_PRED_MODE mb_pred_mode = MB_PRED_MODE_NA;

        ret = CH264MacroBlock::MbPartPredMode2(picture.m_mbs[mbAddrN_B].m_name_of_mb_type, mbPartIdxN_B, picture.m_mbs[mbAddrN_B].transform_size_8x8_flag, mb_pred_mode);
        RETURN_IF_FAILED(ret != 0, ret);
        
        if (((is_mvd_10 == 1 && mb_pred_mode != Pred_L0) || (is_mvd_10 == 0 && mb_pred_mode != Pred_L1)) && mb_pred_mode != BiPred)
        {
            predModeEqualFlagB = 0;
        }
        else
        {
            predModeEqualFlagB = 1;
        }
    }
    else //if (mbAddrN_B < 0)
    {
        predModeEqualFlagB = 0; //FIXME:
    }

    if (mbAddrN_B < 0
        || (picture.m_mbs[mbAddrN_B].m_name_of_mb_type == P_Skip || picture.m_mbs[mbAddrN_B].m_name_of_mb_type == B_Skip)
        || IS_INTRA_Prediction_Mode(picture.m_mbs[mbAddrN_B].m_mb_pred_mode)
        || predModeEqualFlagB == 0
       )
    {
        absMvdCompB = 0;
    }
    else
    {
        //If compIdx is equal to 1, MbaffFrameFlag is equal to 1, the current macroblock is a frame macroblock, and the macroblock mbAddrN is a field macroblock,
        if (compIdx == 1
            && mb.MbaffFrameFlag == 1
            && mb.mb_field_decoding_flag == 0
            && picture.m_mbs[mbAddrN_B].mb_field_decoding_flag == 1
            )
        {
            if (is_mvd_10 == 1)
            {
                absMvdCompB = ABS( picture.m_mbs[mbAddrN_B].mvd_l0[ mbPartIdxN_B ][ subMbPartIdxN_B ][ compIdx ] ) * 2;
            }
            else //if (is_mvd_10 == 0)
            {
                absMvdCompB = ABS( picture.m_mbs[mbAddrN_B].mvd_l1[ mbPartIdxN_B ][ subMbPartIdxN_B ][ compIdx ] ) * 2;
            }
        }
        else if (compIdx == 1
            && mb.MbaffFrameFlag == 1
            && mb.mb_field_decoding_flag == 1
            && picture.m_mbs[mbAddrN_B].mb_field_decoding_flag == 0
            )
        {
            if (is_mvd_10 == 1)
            {
                absMvdCompB = ABS( picture.m_mbs[mbAddrN_B].mvd_l0[ mbPartIdxN_B ][ subMbPartIdxN_B ][ compIdx ] ) / 2;
            }
            else //if (is_mvd_10 == 0)
            {
                absMvdCompB = ABS( picture.m_mbs[mbAddrN_B].mvd_l1[ mbPartIdxN_B ][ subMbPartIdxN_B ][ compIdx ] ) / 2;
            }
        }
        else
        {
            if (is_mvd_10 == 1)
            {
                absMvdCompB = ABS( picture.m_mbs[mbAddrN_B].mvd_l0[ mbPartIdxN_B ][ subMbPartIdxN_B ][ compIdx ] );
            }
            else //if (is_mvd_10 == 0)
            {
                absMvdCompB = ABS( picture.m_mbs[mbAddrN_B].mvd_l1[ mbPartIdxN_B ][ subMbPartIdxN_B ][ compIdx ] );
            }
        }
    }

    //----------------------
    if ( (absMvdCompA + absMvdCompB ) < 3)
    {
        ctxIdxInc = 0;
    }
    else if ( (absMvdCompA + absMvdCompB ) > 32)
    {
        ctxIdxInc = 2;
    }
    else //if ( (absMvdCompA + absMvdCompB ) >= 3 && (absMvdCompA + absMvdCompB ) <= 32)
    {
        ctxIdxInc = 1;
    }

    return 0;
}


//9.3.3.1.1.8 Derivation process of ctxIdxInc for the syntax element intra_chroma_pred_mode
int CH264Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_intra_chroma_pred_mode(CH264PictureBase &picture, int32_t &ctxIdxInc)
{
    int ret = 0;

    int32_t mbAddrA = 0;
    int32_t mbAddrB = 0;
    int32_t isChroma = 0;

    //6.4.11.1 Derivation process for neighbouring macroblocks
    ret = picture.Derivation_process_for_neighbouring_macroblocks(picture.m_h264_slice_header.MbaffFrameFlag, picture.CurrMbAddr, mbAddrA, mbAddrB, isChroma);
    RETURN_IF_FAILED(ret != 0, ret);

    int32_t condTermFlagA = 0;
    int32_t condTermFlagB = 0;

    //----------A------------
    if (mbAddrA < 0
        || IS_INTRA_Prediction_Mode(picture.m_mbs[mbAddrA].m_mb_pred_mode) == false
        || picture.m_mbs[mbAddrA].m_name_of_mb_type == I_PCM
        || picture.m_mbs[mbAddrA].intra_chroma_pred_mode == 0
       )
    {
        condTermFlagA = 0;
    }
    else
    {
        condTermFlagA = 1;
    }
    
    //----------B------------
    if (mbAddrB < 0
        || IS_INTRA_Prediction_Mode(picture.m_mbs[mbAddrB].m_mb_pred_mode) == false
        || picture.m_mbs[mbAddrB].m_name_of_mb_type == I_PCM
        || picture.m_mbs[mbAddrB].intra_chroma_pred_mode == 0
       )
    {
        condTermFlagB = 0;
    }
    else
    {
        condTermFlagB = 1;
    }

    //------------------
    ctxIdxInc = condTermFlagA + condTermFlagB;

    return 0;
}


//9.3.3.1.1.9 Derivation process of ctxIdxInc for the syntax element coded_block_flag
//ctxIdxInc( ctxBlockCat )
int CH264Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_flag(CH264PictureBase &picture, int32_t ctxBlockCat, 
                    int32_t BlkIdx, int32_t iCbCr, int32_t &ctxIdxInc)
{
    int ret = 0;

    int32_t i = 0;
    int32_t mbAddrA = 0;
    int32_t mbAddrB = 0;
    int32_t transBlockA = -1;
    int32_t transBlockB = -1;
    int32_t transBlockA_coded_block_flag = 0;
    int32_t transBlockB_coded_block_flag = 0;
    int32_t non_zero_count_coeff = 0;

    if (ctxBlockCat == 0 //MB_RESIDUAL_Intra16x16DCLevel
        || ctxBlockCat == 6 //MB_RESIDUAL_CbIntra16x16DCLevel
        || ctxBlockCat == 10 //MB_RESIDUAL_CrIntra16x16DCLevel
       )
    {
        int32_t isChroma = (iCbCr < 0) ? 0 : 1;

        //6.4.11.1 Derivation process for neighbouring macroblocks
        ret = picture.Derivation_process_for_neighbouring_macroblocks(picture.m_h264_slice_header.MbaffFrameFlag, picture.CurrMbAddr, mbAddrA, mbAddrB, isChroma);
        RETURN_IF_FAILED(ret != 0, ret);

        //1. If ctxBlockCat is equal to 0, the luma DC block of macroblock mbAddrN is assigned to transBlockN.
        //2. Otherwise, if ctxBlockCat is equal to 6, the Cb DC block of macroblock mbAddrN is assigned to transBlockN.
        //3. Otherwise (ctxBlockCat is equal to 10), the Cr DC block of macroblock mbAddrN is assigned to transBlockN.

        //----------A------------
        if (mbAddrA >= 0
            && picture.m_mbs[mbAddrA].m_mb_pred_mode == Intra_16x16
           )
        {
            transBlockA = 1;
            transBlockA_coded_block_flag = (picture.m_mbs[mbAddrA].coded_block_flag_DC_pattern >> (iCbCr + 1)) & 1;
        }
        else
        {
            transBlockA = -1; //transBlockN is marked as not available.
        }
        
        //----------B------------
        if (mbAddrB >= 0
            && picture.m_mbs[mbAddrB].m_mb_pred_mode == Intra_16x16
           )
        {
            transBlockB = 1;
            transBlockB_coded_block_flag = (picture.m_mbs[mbAddrB].coded_block_flag_DC_pattern >> (iCbCr + 1)) & 1;
        }
        else
        {
            transBlockB = -1; //transBlockN is marked as not available.
        }
    }
    else if (ctxBlockCat == 1 //MB_RESIDUAL_Intra16x16ACLevel
             || ctxBlockCat == 2 //MB_RESIDUAL_LumaLevel4x4
            )
    {
        //6.4.11.4 Derivation process for neighbouring 4x4 luma blocks
        int32_t luma4x4BlkIdx = BlkIdx;
        int32_t luma4x4BlkIdxA = 0;
        int32_t luma4x4BlkIdxB = 0;
        int32_t isChroma = (iCbCr < 0) ? 0 : 1;

        ret = picture.Derivation_process_for_neighbouring_4x4_luma_blocks(luma4x4BlkIdx, mbAddrA, mbAddrB, luma4x4BlkIdxA, luma4x4BlkIdxB, isChroma);
        RETURN_IF_FAILED(ret != 0, -1);
        
        //----------A------------
        if (mbAddrA >= 0
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != I_PCM
            && (( picture.m_mbs[mbAddrA].CodedBlockPatternLuma >> ( luma4x4BlkIdxA >> 2 ) ) & 1) != 0
            && picture.m_mbs[mbAddrA].transform_size_8x8_flag == 0
           )
        {
            transBlockA = 1;
            transBlockA_coded_block_flag = (picture.m_mbs[mbAddrA].coded_block_flag_AC_pattern[iCbCr + 1] >> (luma4x4BlkIdxA)) & 1;
        }
        else if (mbAddrA >= 0
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != B_Skip
            && (( picture.m_mbs[mbAddrA].CodedBlockPatternLuma >> ( luma4x4BlkIdxA >> 2 ) ) & 1) != 0
            && picture.m_mbs[mbAddrA].transform_size_8x8_flag == 1
           )
        {
            transBlockA = 1;
            transBlockA_coded_block_flag = (picture.m_mbs[mbAddrA].coded_block_flag_AC_pattern[iCbCr + 1] >> (luma4x4BlkIdxA >> 2)) & 1;
        }
        else
        {
            transBlockA = -1; //transBlockN is marked as not available.
        }
        
        //----------B------------
        if (mbAddrB >= 0
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != I_PCM
            && (( picture.m_mbs[mbAddrB].CodedBlockPatternLuma >> ( luma4x4BlkIdxB >> 2 ) ) & 1) != 0
            && picture.m_mbs[mbAddrB].transform_size_8x8_flag == 0
           )
        {
            transBlockB = 1;
            transBlockB_coded_block_flag = (picture.m_mbs[mbAddrB].coded_block_flag_AC_pattern[iCbCr + 1] >> (luma4x4BlkIdxB)) & 1;
        }
        else if (mbAddrB >= 0
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != B_Skip
            && (( picture.m_mbs[mbAddrB].CodedBlockPatternLuma >> ( luma4x4BlkIdxB >> 2 ) ) & 1) != 0
            && picture.m_mbs[mbAddrB].transform_size_8x8_flag == 1
           )
        {
            transBlockB = 1;
            transBlockB_coded_block_flag = (picture.m_mbs[mbAddrB].coded_block_flag_AC_pattern[iCbCr + 1] >> (luma4x4BlkIdxB >> 2)) & 1;
        }
        else
        {
            transBlockB = -1; //transBlockN is marked as not available.
        }
    }
    else if (ctxBlockCat == 3) //MB_RESIDUAL_ChromaDCLevel
    {
        int32_t isChroma = 1;

        //6.4.11.1 Derivation process for neighbouring macroblocks
        ret = picture.Derivation_process_for_neighbouring_macroblocks(picture.m_h264_slice_header.MbaffFrameFlag, picture.CurrMbAddr, mbAddrA, mbAddrB, isChroma);
        RETURN_IF_FAILED(ret != 0, ret);

        //----------A------------
        if (mbAddrA >= 0
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != I_PCM
            && picture.m_mbs[mbAddrA].CodedBlockPatternChroma != 0
           )
        {
            transBlockA = 1;
            transBlockA_coded_block_flag = (picture.m_mbs[mbAddrA].coded_block_flag_DC_pattern >> (iCbCr + 1)) & 1;
        }
        else
        {
            transBlockA = -1; //transBlockN is marked as not available.
        }
        
        //----------B------------
        if (mbAddrB >= 0
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != I_PCM
            && picture.m_mbs[mbAddrB].CodedBlockPatternChroma != 0
           )
        {
            transBlockB = 1;
            transBlockB_coded_block_flag = (picture.m_mbs[mbAddrB].coded_block_flag_DC_pattern >> (iCbCr + 1)) & 1;
        }
        else
        {
            transBlockB = -1; //transBlockN is marked as not available.
        }
    }
    else if (ctxBlockCat == 4) //MB_RESIDUAL_ChromaACLevel
    {
        int32_t chroma4x4BlkIdx = BlkIdx;
        int32_t chroma4x4BlkIdxA = 0;
        int32_t chroma4x4BlkIdxB = 0;
        int32_t isChroma = 1;

        //6.4.11.5 Derivation process for neighbouring 4x4 chroma blocks
        ret = picture.Derivation_process_for_neighbouring_4x4_chroma_blocks(chroma4x4BlkIdx, mbAddrA, mbAddrB, chroma4x4BlkIdxA, chroma4x4BlkIdxB);
        RETURN_IF_FAILED(ret != 0, ret);

        //----------A------------
        if (mbAddrA >= 0
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != I_PCM
            && picture.m_mbs[mbAddrA].CodedBlockPatternChroma == 2
           )
        {
            transBlockA = 1;
            transBlockA_coded_block_flag = (picture.m_mbs[mbAddrA].coded_block_flag_AC_pattern[iCbCr + 1] >> (chroma4x4BlkIdxA)) & 1;
        }
        else
        {
            transBlockA = -1; //transBlockN is marked as not available.
        }
        
        //----------B------------
        if (mbAddrB >= 0
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != I_PCM
            && picture.m_mbs[mbAddrB].CodedBlockPatternChroma == 2
           )
        {
            transBlockB = 1;
            transBlockB_coded_block_flag = (picture.m_mbs[mbAddrB].coded_block_flag_AC_pattern[iCbCr + 1] >> (chroma4x4BlkIdxB)) & 1;
        }
        else
        {
            transBlockB = -1; //transBlockN is marked as not available.
        }
    }
    else if (ctxBlockCat == 5) //MB_RESIDUAL_LumaLevel8x8
    {
        int32_t luma8x8BlkIdx = BlkIdx;
        int32_t luma8x8BlkIdxA = 0;
        int32_t luma8x8BlkIdxB = 0;
        int32_t isChroma = 0;

        //6.4.11.2 Derivation process for neighbouring 8x8 luma block
        ret = picture.Derivation_process_for_neighbouring_8x8_luma_block(luma8x8BlkIdx, mbAddrA, mbAddrB, luma8x8BlkIdxA, luma8x8BlkIdxB, isChroma);
        RETURN_IF_FAILED(ret != 0, -1);
        
        //----------A------------
        if (mbAddrA >= 0
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != I_PCM
            && ( ( picture.m_mbs[mbAddrA].CodedBlockPatternLuma >>luma8x8BlkIdx) & 1 ) != 0
            && picture.m_mbs[mbAddrA].transform_size_8x8_flag == 1
           )
        {
            transBlockA = 1;
            transBlockA_coded_block_flag = (picture.m_mbs[mbAddrA].coded_block_flag_AC_pattern[iCbCr + 1] >> (luma8x8BlkIdxA)) & 1;
        }
        else
        {
            transBlockA = -1; //transBlockN is marked as not available.
        }
        
        //----------B------------
        if (mbAddrB >= 0
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != I_PCM
            && ( ( picture.m_mbs[mbAddrB].CodedBlockPatternLuma >>luma8x8BlkIdx) & 1 ) != 0
            && picture.m_mbs[mbAddrB].transform_size_8x8_flag == 1
           )
        {
            transBlockB = 1;
            transBlockB_coded_block_flag = (picture.m_mbs[mbAddrB].coded_block_flag_AC_pattern[iCbCr + 1] >> (luma8x8BlkIdxB)) & 1;
        }
        else
        {
            transBlockB = -1; //transBlockN is marked as not available.
        }
    }
    else if (ctxBlockCat == 7 //MB_RESIDUAL_CbIntra16x16ACLevel
             || ctxBlockCat == 8 //MB_RESIDUAL_CbLevel4x4
            )
    {
        int32_t cb4x4BlkIdx = BlkIdx;
        int32_t cb4x4BlkIdxA = 0;
        int32_t cb4x4BlkIdxB = 0;

        //6.4.11.5 Derivation process for neighbouring 4x4 chroma blocks
        ret = picture.Derivation_process_for_neighbouring_4x4_chroma_blocks(cb4x4BlkIdx, mbAddrA, mbAddrB, cb4x4BlkIdxA, cb4x4BlkIdxB);
        RETURN_IF_FAILED(ret != 0, ret);

        //----------A------------
        if (mbAddrA >= 0
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != I_PCM
            && ((picture.m_mbs[mbAddrA].CodedBlockPatternLuma >> (cb4x4BlkIdxA >> 2)) & 1) != 0
            && picture.m_mbs[mbAddrA].transform_size_8x8_flag == 0
           )
        {
            transBlockA = 1;
            transBlockA_coded_block_flag = (picture.m_mbs[mbAddrA].coded_block_flag_AC_pattern[iCbCr + 1] >> (cb4x4BlkIdxA)) & 1;
        }
        else if (mbAddrA >= 0
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != B_Skip
            && ((picture.m_mbs[mbAddrA].CodedBlockPatternLuma >> (cb4x4BlkIdxA >> 2)) & 1) != 0
            && picture.m_mbs[mbAddrA].transform_size_8x8_flag == 1
           )
        {
            transBlockA = 1;
            transBlockA_coded_block_flag = (picture.m_mbs[mbAddrA].coded_block_flag_AC_pattern[iCbCr + 1] >> (cb4x4BlkIdxA >> 2)) & 1;
        }
        else
        {
            transBlockA = -1; //transBlockN is marked as not available.
        }
        
        //----------B------------
        if (mbAddrB >= 0
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != I_PCM
            && ((picture.m_mbs[mbAddrB].CodedBlockPatternLuma >> (cb4x4BlkIdxB >> 2)) & 1) != 0
            && picture.m_mbs[mbAddrB].transform_size_8x8_flag == 0
           )
        {
            transBlockB = 1;
            transBlockB_coded_block_flag = (picture.m_mbs[mbAddrB].coded_block_flag_AC_pattern[iCbCr + 1] >> (cb4x4BlkIdxB)) & 1;
        }
        else if (mbAddrB >= 0
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != B_Skip
            && ((picture.m_mbs[mbAddrB].CodedBlockPatternLuma >> (cb4x4BlkIdxB >> 2)) & 1) != 0
            && picture.m_mbs[mbAddrB].transform_size_8x8_flag == 1
           )
        {
            transBlockB = 1;
            transBlockB_coded_block_flag = (picture.m_mbs[mbAddrB].coded_block_flag_AC_pattern[iCbCr + 1] >> (cb4x4BlkIdxB >> 2)) & 1;
        }
        else
        {
            transBlockB = -1; //transBlockN is marked as not available.
        }
    }
    else if (ctxBlockCat == 9) //MB_RESIDUAL_CbLevel8x8
    {
        int32_t cb8x8BlkIdx = BlkIdx;
        int32_t cb8x8BlkIdxA = 0;
        int32_t cb8x8BlkIdxB = 0;

        //6.4.11.3 Derivation process for neighbouring 8x8 chroma blocks for ChromaArrayType equal to 3
        ret = picture.Derivation_process_for_neighbouring_8x8_chroma_blocks_for_ChromaArrayType_equal_to_3(cb8x8BlkIdx, mbAddrA, mbAddrB, cb8x8BlkIdxA, cb8x8BlkIdxB);
        RETURN_IF_FAILED(ret != 0, -1);
        
        //----------A------------
        if (mbAddrA >= 0
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != I_PCM
            && ( ( picture.m_mbs[mbAddrA].CodedBlockPatternLuma >> cb8x8BlkIdx) & 1 ) != 0
            && picture.m_mbs[mbAddrA].transform_size_8x8_flag == 1
           )
        {
            transBlockA = 1;
            transBlockA_coded_block_flag = (picture.m_mbs[mbAddrA].coded_block_flag_AC_pattern[iCbCr + 1] >> (cb8x8BlkIdxA)) & 1;
        }
        else
        {
            transBlockA = -1; //transBlockN is marked as not available.
        }
        
        //----------B------------
        if (mbAddrB >= 0
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != I_PCM
            && ( ( picture.m_mbs[mbAddrB].CodedBlockPatternLuma >> cb8x8BlkIdx) & 1 ) != 0
            && picture.m_mbs[mbAddrB].transform_size_8x8_flag == 1
           )
        {
            transBlockB = 1;
            transBlockB_coded_block_flag = (picture.m_mbs[mbAddrB].coded_block_flag_AC_pattern[iCbCr + 1] >> (cb8x8BlkIdxB)) & 1;
        }
        else
        {
            transBlockB = -1; //transBlockN is marked as not available.
        }
    }
    else if (ctxBlockCat == 11 //MB_RESIDUAL_CrIntra16x16ACLevel
             || ctxBlockCat == 12 //MB_RESIDUAL_CrLevel4x4
            )
    {
        int32_t cr4x4BlkIdx = BlkIdx;
        int32_t cr4x4BlkIdxA = 0;
        int32_t cr4x4BlkIdxB = 0;

        //6.4.11.5 Derivation process for neighbouring 4x4 chroma blocks
        ret = picture.Derivation_process_for_neighbouring_4x4_chroma_blocks(cr4x4BlkIdx, mbAddrA, mbAddrB, cr4x4BlkIdxA, cr4x4BlkIdxB);
        RETURN_IF_FAILED(ret != 0, ret);

        //----------A------------
        if (mbAddrA >= 0
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != I_PCM
            && ((picture.m_mbs[mbAddrA].CodedBlockPatternLuma >> (cr4x4BlkIdxA >> 2)) & 1) != 0
            && picture.m_mbs[mbAddrA].transform_size_8x8_flag == 0
           )
        {
            transBlockA = 1;
            transBlockA_coded_block_flag = (picture.m_mbs[mbAddrA].coded_block_flag_AC_pattern[iCbCr + 1] >> (cr4x4BlkIdxA)) & 1;
        }
        else if (mbAddrA >= 0
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != B_Skip
            && ((picture.m_mbs[mbAddrA].CodedBlockPatternLuma >> (cr4x4BlkIdxA >> 2)) & 1) != 0
            && picture.m_mbs[mbAddrA].transform_size_8x8_flag == 1
           )
        {
            transBlockA = 1;
            transBlockA_coded_block_flag = (picture.m_mbs[mbAddrA].coded_block_flag_AC_pattern[iCbCr + 1] >> (cr4x4BlkIdxA >> 2)) & 1;
        }
        else
        {
            transBlockA = -1; //transBlockN is marked as not available.
        }
        
        //----------B------------
        if (mbAddrA >= 0
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != I_PCM
            && ((picture.m_mbs[mbAddrB].CodedBlockPatternLuma >> (cr4x4BlkIdxB >> 2)) & 1) != 0
            && picture.m_mbs[mbAddrB].transform_size_8x8_flag == 0
           )
        {
            transBlockB = 1;
            transBlockB_coded_block_flag = (picture.m_mbs[mbAddrB].coded_block_flag_AC_pattern[iCbCr + 1] >> (cr4x4BlkIdxB)) & 1;
        }
        else if (mbAddrB >= 0
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != B_Skip
            && ((picture.m_mbs[mbAddrB].CodedBlockPatternLuma >> (cr4x4BlkIdxB >> 2)) & 1) != 0
            && picture.m_mbs[mbAddrB].transform_size_8x8_flag == 1
           )
        {
            transBlockB = 1;
            transBlockB_coded_block_flag = (picture.m_mbs[mbAddrB].coded_block_flag_AC_pattern[iCbCr + 1] >> (cr4x4BlkIdxB >> 2)) & 1;
        }
        else
        {
            transBlockB = -1; //transBlockN is marked as not available.
        }
    }
    else //if (ctxBlockCat == 13) //MB_RESIDUAL_CrLevel8x8
    {
        int32_t cr8x8BlkIdx = BlkIdx;
        int32_t cr8x8BlkIdxA = 0;
        int32_t cr8x8BlkIdxB = 0;

        //6.4.11.3 Derivation process for neighbouring 8x8 chroma blocks for ChromaArrayType equal to 3
        ret = picture.Derivation_process_for_neighbouring_8x8_chroma_blocks_for_ChromaArrayType_equal_to_3(cr8x8BlkIdx, mbAddrA, mbAddrB, cr8x8BlkIdxA, cr8x8BlkIdxB);
        RETURN_IF_FAILED(ret != 0, -1);
        
        //----------A------------
        if (mbAddrA >= 0
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrA].m_name_of_mb_type != I_PCM
            && ( ( picture.m_mbs[mbAddrA].CodedBlockPatternLuma >> cr8x8BlkIdx) & 1 ) != 0
            && picture.m_mbs[mbAddrA].transform_size_8x8_flag == 1
           )
        {
            transBlockA = 1;
            transBlockA_coded_block_flag = (picture.m_mbs[mbAddrA].coded_block_flag_AC_pattern[iCbCr + 1] >> (cr8x8BlkIdxA)) & 1;
        }
        else
        {
            transBlockA = -1; //transBlockN is marked as not available.
        }
        
        //----------B------------
        if (mbAddrB >= 0
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != P_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != B_Skip
            && picture.m_mbs[mbAddrB].m_name_of_mb_type != I_PCM
            && ( ( picture.m_mbs[mbAddrB].CodedBlockPatternLuma >> cr8x8BlkIdx) & 1 ) != 0
            && picture.m_mbs[mbAddrB].transform_size_8x8_flag == 1
           )
        {
            transBlockB = 1;
            transBlockB_coded_block_flag = (picture.m_mbs[mbAddrB].coded_block_flag_AC_pattern[iCbCr + 1] >> (cr8x8BlkIdxB)) & 1;
        }
        else
        {
            transBlockB = -1; //transBlockN is marked as not available.
        }
    }

    //------------------------
    int32_t condTermFlagA = 0;
    int32_t condTermFlagB = 0;
    
    //----------A------------
    if ( (mbAddrA < 0 && IS_INTRA_Prediction_Mode(picture.m_mbs[picture.CurrMbAddr].m_mb_pred_mode) == false)
        || (mbAddrA >= 0 && transBlockA == -1 && picture.m_mbs[mbAddrA].m_name_of_mb_type != I_PCM)
        || (IS_INTRA_Prediction_Mode(picture.m_mbs[picture.CurrMbAddr].m_mb_pred_mode)
            && picture.m_mbs[picture.CurrMbAddr].constrained_intra_pred_flag == 1
            && mbAddrA >= 0 && IS_INTRA_Prediction_Mode(picture.m_mbs[mbAddrA].m_mb_pred_mode) == false
            && (picture.m_h264_slice_header.m_nal_unit.nal_unit_type >= 2 && picture.m_h264_slice_header.m_nal_unit.nal_unit_type <= 4)
          )
       )
    {
        condTermFlagA = 0;
    }
    else if (mbAddrA < 0 && IS_INTRA_Prediction_Mode(picture.m_mbs[picture.CurrMbAddr].m_mb_pred_mode)
             || picture.m_mbs[mbAddrA].m_name_of_mb_type == I_PCM
            )
    {
        condTermFlagA = 1;
    }
    else
    {
        //condTermFlagN is set equal to the value of the coded_block_flag of the transform block 
        //transBlockN that was decoded for the macroblock mbAddrN.
        condTermFlagA = transBlockA_coded_block_flag;
    }
    
    //----------B------------
    if ( (mbAddrB < 0 && IS_INTRA_Prediction_Mode(picture.m_mbs[picture.CurrMbAddr].m_mb_pred_mode) == false)
        || (mbAddrB >= 0 && transBlockB == -1 && picture.m_mbs[mbAddrB].m_name_of_mb_type != I_PCM)
        || (IS_INTRA_Prediction_Mode(picture.m_mbs[picture.CurrMbAddr].m_mb_pred_mode)
            && picture.m_mbs[picture.CurrMbAddr].constrained_intra_pred_flag == 1
            && mbAddrB >= 0 && IS_INTRA_Prediction_Mode(picture.m_mbs[mbAddrB].m_mb_pred_mode) == false
            && (picture.m_h264_slice_header.m_nal_unit.nal_unit_type >= 2 && picture.m_h264_slice_header.m_nal_unit.nal_unit_type <= 4)
          )
       )
    {
        condTermFlagB = 0;
    }
    else if (mbAddrB < 0 && IS_INTRA_Prediction_Mode(picture.m_mbs[picture.CurrMbAddr].m_mb_pred_mode)
             || picture.m_mbs[mbAddrB].m_name_of_mb_type == I_PCM
            )
    {
        condTermFlagB = 1;
    }
    else
    {
        //condTermFlagN is set equal to the value of the coded_block_flag of the transform block 
        //transBlockN that was decoded for the macroblock mbAddrN.
        condTermFlagB = transBlockB_coded_block_flag;
    }

    //------ctxIdxInc( ctxBlockCat )--------------
    ctxIdxInc = condTermFlagA + 2 * condTermFlagB;

    return 0;
}


//9.3.3.1.1.10 Derivation process of ctxIdxInc for the syntax element transform_size_8x8_flag
int CH264Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_transform_size_8x8_flag(CH264PictureBase &picture, int32_t &ctxIdxInc)
{
    int ret = 0;

    int32_t mbAddrA = 0;
    int32_t mbAddrB = 0;
    int32_t isChroma = 0;

    //6.4.11.1 Derivation process for neighbouring macroblocks
    ret = picture.Derivation_process_for_neighbouring_macroblocks(picture.m_h264_slice_header.MbaffFrameFlag, picture.CurrMbAddr, mbAddrA, mbAddrB, isChroma);
    RETURN_IF_FAILED(ret != 0, ret);

    int32_t condTermFlagA = 0;
    int32_t condTermFlagB = 0;

    //----------A------------
    if (mbAddrA < 0
        || picture.m_mbs[mbAddrA].transform_size_8x8_flag == 0
       )
    {
        condTermFlagA = 0;
    }
    else
    {
        condTermFlagA = 1;
    }
    
    //----------B------------
    if (mbAddrB < 0
        || picture.m_mbs[mbAddrB].transform_size_8x8_flag == 0
       )
    {
        condTermFlagB = 0;
    }
    else
    {
        condTermFlagB = 1;
    }

    //-------------------
    ctxIdxInc = condTermFlagA + condTermFlagB;

    return 0;
}


//9.3.3.2.1 Arithmetic decoding process for a binary decision
//二进制判决的算术解码过程 DecodeDecision(ctxIdx)
int CH264Cabac::DecodeDecision(CBitstream &bs, int32_t ctxIdx, int32_t &binVal)
{
    int ret = 0;
    
    //Table 9-45 – State transition table
    const int32_t transIdxLPS[64] = 
    {
        0, 0, 1, 2, 2, 4, 4, 5, 6, 7, 8, 9, 9, 11, 11, 12,
        13, 13, 15, 15, 16, 16, 18, 18, 19, 19, 21, 21, 22, 22, 23, 24,
        24, 25, 26, 26, 27, 27, 28, 29, 29, 30, 30, 30, 31, 32, 32, 33,
        33, 33, 34, 34, 35, 35, 35, 36, 36, 36, 37, 37, 37, 38, 38, 63
    };

    const int32_t transIdxMPS[64] = 
    {
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
        33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
        49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 62, 63
    };
    
    //----------------------------
    //Table 9-44 – Specification of rangeTabLPS depending on pStateIdx and qCodIRangeIdx
    const int32_t rangeTabLPS[64][4] = 
    {
        {128, 176, 208, 240},
        {128, 167, 197, 227},
        {128, 158, 187, 216},
        {123, 150, 178, 205},
        {116, 142, 169, 195},
        {111, 135, 160, 185},
        {105, 128, 152, 175},
        {100, 122, 144, 166},
        {95, 116, 137, 158},
        {90, 110, 130, 150},
        {85, 104, 123, 142},
        {81, 99, 117, 135},
        {77, 94, 111, 128},
        {73, 89, 105, 122},
        {69, 85, 100, 116},
        {66, 80, 95, 110},
        {62, 76, 90, 104},
        {59, 72, 86, 99},
        {56, 69, 81, 94},
        {53, 65, 77, 89},
        {51, 62, 73, 85},
        {48, 59, 69, 80},
        {46, 56, 66, 76},
        {43, 53, 63, 72},
        {41, 50, 59, 69},
        {39, 48, 56, 65},
        {37, 45, 54, 62},
        {35, 43, 51, 59},
        {33, 41, 48, 56},
        {32, 39, 46, 53},
        {30, 37, 43, 50},
        {29, 35, 41, 48},
        {27, 33, 39, 45},
        {26, 31, 37, 43},
        {24, 30, 35, 41},
        {23, 28, 33, 39},
        {22, 27, 32, 37},
        {21, 26, 30, 35},
        {20, 24, 29, 33},
        {19, 23, 27, 31},
        {18, 22, 26, 30},
        {17, 21, 25, 28},
        {16, 20, 23, 27},
        {15, 19, 22, 25},
        {14, 18, 21, 24},
        {14, 17, 20, 23},
        {13, 16, 19, 22},
        {12, 15, 18, 21},
        {12, 14, 17, 20},
        {11, 14, 16, 19},
        {11, 13, 15, 18},
        {10, 12, 15, 17},
        {10, 12, 14, 16},
        {9, 11, 13, 15},
        {9, 11, 12, 14},
        {8, 10, 12, 14},
        {8, 9, 11, 13},
        {7, 9, 11, 12},
        {7, 9, 10, 12},
        {7, 8, 10, 11},
        {6, 8, 9, 11},
        {6, 7, 9, 10},
        {6, 7, 8, 9},
        {2, 2, 2, 2},
    };

    //----------------------------
    int32_t & codIRange = m_codIRange;
    int32_t & codIOffset = m_codIOffset;

    int32_t pStateIdx = m_pStateIdxs[ctxIdx];
    int32_t valMPS = m_valMPSs[ctxIdx];

    int32_t qCodIRangeIdx = ( codIRange >> 6 ) & 3;

    int32_t codIRangeLPS = rangeTabLPS[ pStateIdx ][ qCodIRangeIdx ];

    codIRange = codIRange - codIRangeLPS;

    if (codIOffset >= codIRange)
    {
        binVal = !valMPS;
        codIOffset = codIOffset - codIRange;
        codIRange = codIRangeLPS;

        if (pStateIdx == 0)
        {
            m_valMPSs[ctxIdx] = 1 - valMPS;
        }
        
        m_pStateIdxs[ctxIdx] = transIdxLPS[pStateIdx]; //9.3.3.2.1.1 State transition process
    }
    else
    {
        binVal = valMPS;

        m_pStateIdxs[ctxIdx] = transIdxMPS[pStateIdx]; //9.3.3.2.1.1 State transition process
    }

    //-------------------------
    //9.3.3.2.2 Renormalization process in the arithmetic decoding engine
    //ret = Renormalization_process_in_the_arithmetic_decoding_engine(bs, codIRange, codIOffset);
    //RETURN_IF_FAILED(ret != 0, -1);
    
    while (codIRange < 256)
    {
        codIRange = codIRange << 1;
        codIOffset = codIOffset << 1;
        codIOffset = codIOffset | bs.readBits(1);
    }

    return 0;
}


//9.3.3.2.2 Renormalization process in the arithmetic decoding engine
//RenormD()
int CH264Cabac::RenormD(CBitstream &bs, int32_t &codIRange, int32_t &codIOffset)
{
    while (codIRange < 256)
    {
        codIRange = codIRange << 1;
        codIOffset = codIOffset << 1;
        codIOffset = codIOffset | bs.readBits(1);
    }

    return 0;
}


//9.3.3.2.3 Bypass decoding process for binary decisions
//DecodeBypass()
int CH264Cabac::DecodeBypass(CBitstream &bs, int32_t &binVal)
{
    int ret = 0;
    
    int32_t & codIRange = m_codIRange;
    int32_t & codIOffset = m_codIOffset;

    codIOffset = codIOffset << 1;
    codIOffset = codIOffset | bs.readBits(1);
    
    if (codIOffset >= codIRange)
    {
        binVal = 1;
        codIOffset = codIOffset - codIRange;
    }
    else
    {
        binVal = 0;
    }

    return 0;
}


//9.3.3.2.4 Decoding process for binary decisions before termination
//DecodeTerminate()
int CH264Cabac::DecodeTerminate(CBitstream &bs, int32_t &binVal)
{
    int ret = 0;
    
    int32_t & codIRange = m_codIRange;
    int32_t & codIOffset = m_codIOffset;

    codIRange = codIRange - 2;
    
    if (codIOffset >= codIRange)
    {
        binVal = 1;
    }
    else
    {
        binVal = 0;

        //RenormD()
        //ret = RenormD(bs, codIRange, codIOffset);
        //RETURN_IF_FAILED(ret != 0, -1);
        
        while (codIRange < 256)
        {
            codIRange = codIRange << 1;
            codIOffset = codIOffset << 1;
            codIOffset = codIOffset | bs.readBits(1);
        }
    }

    return 0;
}


//9.3.3.2 Arithmetic decoding process
//DecodeBin(ctxIdx)
int CH264Cabac::DecodeBin(CBitstream &bs, int32_t bypassFlag, int32_t ctxIdx, int32_t &binVal)
{
    int ret = 0;
    
    if (bypassFlag == 1)
    {
        //DecodeBypass()
        ret = DecodeBypass(bs, binVal);
        RETURN_IF_FAILED(ret != 0, -1);
    }
    else
    {
        if (ctxIdx == 276) //decoding of end_of_slice_flag and of the bin indicating the I_PCM
        {
            //DecodeTerminate()
            ret = DecodeTerminate(bs, binVal);
            RETURN_IF_FAILED(ret != 0, -1);
        }
        else
        {
            //DecodeDecision(ctxIdx)
            ret = DecodeDecision(bs, ctxIdx, binVal);
            RETURN_IF_FAILED(ret != 0, -1);
        }
    }

    return 0;
}


//-------------------------------------------
int CH264Cabac::CABAC_decode_mb_type(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;

    H264_SLIECE_TYPE slice_type = (H264_SLIECE_TYPE)picture.m_h264_slice_header.slice_type;

    //Table 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset
    if ((slice_type % 5) == H264_SLIECE_TYPE_SI)
    {
        ret = CABAC_decode_mb_type_in_SI_slices(picture, bs, synElVal);
        RETURN_IF_FAILED(ret != 0, -1);
    }
    else if ((slice_type % 5) == H264_SLIECE_TYPE_I)
    {
        int32_t ctxIdxOffset = 3; //Table 9-34

        ret = CABAC_decode_mb_type_in_I_slices(picture, bs, ctxIdxOffset, synElVal);
        RETURN_IF_FAILED(ret != 0, -1);
    }
    else if ((slice_type % 5) == H264_SLIECE_TYPE_P || (slice_type % 5) == H264_SLIECE_TYPE_SP)
    {
        ret = CABAC_decode_mb_type_in_P_SP_slices(picture, bs, synElVal);
        RETURN_IF_FAILED(ret != 0, -1);
    }
    else if ((slice_type % 5) == H264_SLIECE_TYPE_B)
    {
        ret = CABAC_decode_mb_type_in_B_slices(picture, bs, synElVal);
        RETURN_IF_FAILED(ret != 0, -1);
    }
    else
    {
        RETURN_IF_FAILED(-1, -1);
    }

    return 0;
}


int CH264Cabac::CABAC_decode_sub_mb_type(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;

    H264_SLIECE_TYPE slice_type = (H264_SLIECE_TYPE)picture.m_h264_slice_header.slice_type;

    //Table 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset
    if ((slice_type % 5) == H264_SLIECE_TYPE_P || (slice_type % 5) == H264_SLIECE_TYPE_SP)
    {
        ret = CABAC_decode_sub_mb_type_in_P_SP_slices(picture, bs, synElVal);
        RETURN_IF_FAILED(ret != 0, -1);
    }
    else if ((slice_type % 5) == H264_SLIECE_TYPE_B)
    {
        ret = CABAC_decode_sub_mb_type_in_B_slices(picture, bs, synElVal);
        RETURN_IF_FAILED(ret != 0, -1);
    }
    else
    {
        RETURN_IF_FAILED(-1, -1);
    }

    return 0;
}


int CH264Cabac::CABAC_decode_mb_type_in_I_slices(CH264PictureBase &picture, CBitstream &bs, int32_t ctxIdxOffset, int32_t &synElVal)
{
    int ret = 0;

    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    //Table 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset

    //------Table 9-34: ctxIdxOffset--------
    //如果是I片中的intra宏块，则ctxIdxOffset = 3; 
    //如果是P/SP片中的intra宏块，则ctxIdxOffset = 17;
    //如果是B片中的intra宏块，则ctxIdxOffset = 32;

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1

    if (ctxIdxOffset == 3) // I slice
    {
        //0,1,2 (clause 9.3.3.1.1.3)
        ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_type(picture, ctxIdxOffset, ctxIdxInc);
        RETURN_IF_FAILED(ret != 0, ret);
    }
    else // P/SP/B slice
    {
        ctxIdxInc = 0;
    }

    ctxIdx = ctxIdxOffset + ctxIdxInc;

    //---------DecodeBin------------------
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);

    if (binVal == 0) //(0)b
    {
        synElVal = 0; //0 (I_NxN), Bin string: 0
    }
    else //if (binVal == 1) //(1)b
    {
        ctxIdx = 276; //ctxIdx = 276 is assigned to the binIdx of mb_type indicating the I_PCM mode.
        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 1;
        RETURN_IF_FAILED(ret != 0, -1);

        if (binVal == 0) //(10)b
        {
            ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 3 : 1);
            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 2;
            RETURN_IF_FAILED(ret != 0, -1);

            if (binVal == 0) //(100)b
            {
                ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 4 : 2);
                ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 3; b3 = binVal;
                RETURN_IF_FAILED(ret != 0, -1);

                if (binVal == 0) //(1000)b //b3=0
                {
                    if (ctxIdxOffset == 3) // I slice
                    {
                        ctxIdx = ctxIdxOffset + 6; //(b3 != 0) ? 5: 6; b3=0; //Table 9-41
                    }
                    else // P/SP/B slice
                    {
                        ctxIdx = ctxIdxOffset + 3; //(b3 != 0) ? 2: 3; b3=0; //Table 9-41
                    }

                    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 4;
                    RETURN_IF_FAILED(ret != 0, -1);

                    if (binVal == 0) //(10000)b
                    {
                        ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3); //(b3 != 0) ? 6: 7; b3=0; //Table 9-41
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(100000)b
                        {
                            synElVal = 1; //1 (I_16x16_0_0_0)
                        }
                        else //if (binVal == 1) //(100001)b
                        {
                            synElVal = 2; //2 (I_16x16_1_0_0)
                        }
                    }
                    else if (binVal == 1) //(10001)b
                    {
                        ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3); //(b3 != 0) ? 6: 7; b3=0; //Table 9-41
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(100010)b
                        {
                            synElVal = 3; //3 (I_16x16_2_0_0)
                        }
                        else //if (binVal == 1) //(100011)b
                        {
                            synElVal = 4; //4 (I_16x16_3_0_0)
                        }
                    }
                }
                else if (binVal == 1) //(1001)b //b3=1
                {
                    if (ctxIdxOffset == 3) // I slice
                    {
                        ctxIdx = ctxIdxOffset + 5; //(b3 != 0) ? 5: 6; b3=1; //Table 9-41
                    }
                    else // P/SP/B slice
                    {
                        ctxIdx = ctxIdxOffset + 2; //(b3 != 0) ? 2: 3; b3=1; //Table 9-41
                    }

                    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 4;
                    RETURN_IF_FAILED(ret != 0, -1);

                    if (binVal == 0) //(10010)b
                    {
                        ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 6 : 3); //(b3 != 0) ? 6: 7; b3=1; //Table 9-41
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(100100)b
                        {
                            ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
                            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 6;
                            RETURN_IF_FAILED(ret != 0, -1);

                            if (binVal == 0) //(1001000)b
                            {
                                synElVal = 5; //5 (I_16x16_0_1_0)
                            }
                            else //if (binVal == 1) //(1001001)b
                            {
                                synElVal = 6; //6 (I_16x16_1_1_0)
                            }
                        }
                        else if (binVal == 1) //(100101)b
                        {
                            ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
                            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 6;
                            RETURN_IF_FAILED(ret != 0, -1);

                            if (binVal == 0) //(1001010)b
                            {
                                synElVal = 7; //7 (I_16x16_2_1_0)
                            }
                            else //if (binVal == 1) //(1001011)b
                            {
                                synElVal = 8; //8 (I_16x16_3_1_0)
                            }
                        }
                    }
                    else if (binVal == 1) //(10011)b
                    {
                        ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 6 : 3); //(b3 != 0) ? 6: 7; b3=1; //Table 9-41
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(100110)b
                        {
                            ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
                            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 6;
                            RETURN_IF_FAILED(ret != 0, -1);

                            if (binVal == 0) //(1001100)b
                            {
                                synElVal = 9; //9 (I_16x16_0_2_0)
                            }
                            else //if (binVal == 1) //(1001101)b
                            {
                                synElVal = 10; //10 (I_16x16_1_2_0)
                            }
                        }
                        else if (binVal == 1) //(100111)b
                        {
                            ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
                            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 6;
                            RETURN_IF_FAILED(ret != 0, -1);

                            if (binVal == 0) //(1001110)b
                            {
                                synElVal = 11; //11 (I_16x16_2_2_0)
                            }
                            else //if (binVal == 1) //(1001111)b
                            {
                                synElVal = 12; //12 (I_16x16_3_2_0)
                            }
                        }
                    }
                }
            }
            else if (binVal == 1) //(101)b
            {
                ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 4 : 2);
                ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 3; b3=binVal;
                RETURN_IF_FAILED(ret != 0, -1);

                if (binVal == 0) //(1010)b //b3=0
                {
                    if (ctxIdxOffset == 3) // I slice
                    {
                        ctxIdx = ctxIdxOffset + 6; //(b3 != 0) ? 5: 6; b3=0; //Table 9-41
                    }
                    else // P/SP/B slice
                    {
                        ctxIdx = ctxIdxOffset + 3; //(b3 != 0) ? 2: 3; b3=0; //Table 9-41
                    }

                    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 4;
                    RETURN_IF_FAILED(ret != 0, -1);

                    if (binVal == 0) //(10100)b
                    {
                        ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3); //(b3 != 0) ? 6: 7; b3=0; //Table 9-41
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(101000)b
                        {
                            synElVal = 13; //13 (I_16x16_0_0_1)
                        }
                        else //if (binVal == 1) //(101001)b
                        {
                            synElVal = 14; //14 (I_16x16_1_0_1)
                        }
                    }
                    else if (binVal == 1) //(10101)b
                    {
                        ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3); //(b3 != 0) ? 6: 7; b3=0; //Table 9-41
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(101010)b
                        {
                            synElVal = 15; //15 (I_16x16_2_0_1)
                        }
                        else //if (binVal == 1) //(101011)b
                        {
                            synElVal = 16; //16 (I_16x16_3_0_1)
                        }
                    }
                }
                else if (binVal == 1) //(1011)b //b3=1
                {
                    if (ctxIdxOffset == 3) // I slice
                    {
                        ctxIdx = ctxIdxOffset + 5; //(b3 != 0) ? 5: 6; b3=1; //Table 9-41
                    }
                    else // P/SP/B slice
                    {
                        ctxIdx = ctxIdxOffset + 2; //(b3 != 0) ? 2: 3; b3=1; //Table 9-41
                    }

                    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 4;
                    RETURN_IF_FAILED(ret != 0, -1);

                    if (binVal == 0) //(10110)b
                    {
                        ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 6 : 3); //(b3 != 0) ? 6: 7; b3=1; //Table 9-41
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(101100)b
                        {
                            ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
                            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 6;
                            RETURN_IF_FAILED(ret != 0, -1);

                            if (binVal == 0) //(1011000)b
                            {
                                synElVal = 17; //17 (I_16x16_0_1_1)
                            }
                            else //if (binVal == 1) //(1011001)b
                            {
                                synElVal = 18; //18 (I_16x16_1_1_1)
                            }
                        }
                        else if (binVal == 1) //(101101)b
                        {
                            ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
                            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 6;
                            RETURN_IF_FAILED(ret != 0, -1);

                            if (binVal == 0) //(1011010)b
                            {
                                synElVal = 19; //19 (I_16x16_2_1_1)
                            }
                            else //if (binVal == 1) //(1011011)b
                            {
                                synElVal = 20; //20 (I_16x16_3_1_1)
                            }
                        }
                    }
                    else if (binVal == 1) //(10111)b
                    {
                        ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 6 : 3); //(b3 != 0) ? 6: 7; b3=1; //Table 9-41
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(101110)b
                        {
                            ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
                            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 6;
                            RETURN_IF_FAILED(ret != 0, -1);

                            if (binVal == 0) //(1011100)b
                            {
                                synElVal = 21; //21 (I_16x16_0_2_1)
                            }
                            else //if (binVal == 1) //(1011101)b
                            {
                                synElVal = 22; //22 (I_16x16_1_2_1)
                            }
                        }
                        else if (binVal == 1) //(101111)b
                        {
                            ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
                            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 6;
                            RETURN_IF_FAILED(ret != 0, -1);

                            if (binVal == 0) //(1011110)b
                            {
                                synElVal = 23; //23 (I_16x16_2_2_1)
                            }
                            else //if (binVal == 1) //(1011111)b
                            {
                                synElVal = 24; //24 (I_16x16_3_2_1)
                            }
                        }
                    }
                }
            }
        }
        else //if (binVal == 1) //(11)b
        {
            synElVal = 25; //25 (I_PCM)
        }
    }

    //--------------------------------------------
    if (synElVal == 25) //&& value(b0,b1,...,bbinIdx) == I_PCM = 25
    {
        ret = Initialisation_process_for_the_arithmetic_decoding_engine(bs);
        RETURN_IF_FAILED(ret != 0, -1);
    }

    return 0;
}


int CH264Cabac::CABAC_decode_mb_type_in_SI_slices(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;
    
    H264_SLIECE_TYPE slice_type = (H264_SLIECE_TYPE)picture.m_h264_slice_header.slice_type;
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    RETURN_IF_FAILED((slice_type % 5) != H264_SLIECE_TYPE_SI, -1);

    //------Table 9-34: ctxIdxOffset-prefix: 0--------
    maxBinIdxCtx = 0;
    ctxIdxOffset = 0;

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1

    //0,1,2 (clause 9.3.3.1.1.3)
    ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_type(picture, ctxIdxOffset, ctxIdxInc);
    RETURN_IF_FAILED(ret != 0, ret);

    ctxIdx = ctxIdxOffset + ctxIdxInc;

    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);

    //int32_t b0 = ( (.m_name_of_mb_type == SI ) ? 0 : 1 );

    if (binVal == 0) //For the syntax element value for which b0 is equal to 0, the bin string only consists of the prefix bit string.
    {
        synElVal = 0; //0 (I_NxN)
    }
    else //if (binVal == 1) //b0 + suffix
    {
        //------Table 9-34: ctxIdxOffset-suffix: 3--------
        maxBinIdxCtx = 6;
        ctxIdxOffset = 3;

        ret = CABAC_decode_mb_type_in_I_slices(picture, bs, ctxIdxOffset, synElVal);
        RETURN_IF_FAILED(ret != 0, -1);

        //the suffix bit string as specified in Table 9-36 for macroblock type in I slices indexed by 
        //subtracting 1 from the value of mb_type in SI slices.
        synElVal += 1;
    }
    
    return 0;
}


int CH264Cabac::CABAC_decode_mb_type_in_P_SP_slices(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;
    
    H264_SLIECE_TYPE slice_type = (H264_SLIECE_TYPE)picture.m_h264_slice_header.slice_type;
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    RETURN_IF_FAILED((slice_type % 5) != H264_SLIECE_TYPE_P && (slice_type % 5) != H264_SLIECE_TYPE_SP, -1);

    //------Table 9-34: ctxIdxOffset-prefix: 14--------
    maxBinIdxCtx = 2;
    ctxIdxOffset = 14;

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1

    ctxIdx = ctxIdxOffset + 0; //ctxIdxOffset + ctxIdxInc = 14 + 0;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);

    if (binVal == 0) //(0)b
    {
        ctxIdx = ctxIdxOffset + 1;
        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 1; b1=binVal;
        RETURN_IF_FAILED(ret != 0, -1);

        if (binVal == 0) //(00)b //b1=0
        {
            ctxIdx = ctxIdxOffset + 2; //(b1 != 1) ? 2: 3; b1=0; //Table 9-41 //2,3 (clause 9.3.3.1.2)
            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 2;
            RETURN_IF_FAILED(ret != 0, -1);

            if (binVal == 0) //(000)b
            {
                synElVal = 0; //0 (P_L0_16x16)
            }
            else //if (binVal == 1) //(001)b
            {
                synElVal = 3; //3 (P_8x8)
            }
        }
        else //if (binVal == 1) //(01)b //b1=1
        {
            ctxIdx = ctxIdxOffset + 3; //(b1 != 1) ? 2: 3; b1=0; //Table 9-41 //2,3 (clause 9.3.3.1.2)
            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 2;
            RETURN_IF_FAILED(ret != 0, -1);

            if (binVal == 0) //(010)b
            {
                synElVal = 2; //2 (P_L0_L0_8x16)
            }
            else //if (binVal == 1) //(011)b
            {
                synElVal = 1; //1 (P_L0_L0_16x8)
            }
        }
    }
    else //if (binVal == 1) //(1)b //5 to 30 (Intra, prefix only)
    {
        //------Table 9-34: ctxIdxOffset-suffix: 17--------
        maxBinIdxCtx = 5;
        ctxIdxOffset = 17;

        ret = CABAC_decode_mb_type_in_I_slices(picture, bs, ctxIdxOffset, synElVal);
        RETURN_IF_FAILED(ret != 0, -1);

        //The bin string for I macroblock types in P and SP slices corresponding to mb_type 
        //values 5 to 30 consists of a concatenation of a prefix, which consists of a single 
        //bit with value equal to 1 as specified in Table 9-37 and a suffix as specified in 
        //Table 9-36, indexed by subtracting 5 from the value of mb_type.
        synElVal += 5;
    }

    return 0;
}


int CH264Cabac::CABAC_decode_mb_type_in_B_slices(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;
    
    H264_SLIECE_TYPE slice_type = (H264_SLIECE_TYPE)picture.m_h264_slice_header.slice_type;
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    RETURN_IF_FAILED((slice_type % 5) != H264_SLIECE_TYPE_B, -1);

    //------Table 9-34: ctxIdxOffset-prefix: 27--------
    maxBinIdxCtx = 3;
    ctxIdxOffset = 27;

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1

    //0,1,2 (clause 9.3.3.1.1.3)
    ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_type(picture, ctxIdxOffset, ctxIdxInc);
    RETURN_IF_FAILED(ret != 0, ret);

    ctxIdx = ctxIdxOffset + ctxIdxInc;

    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);

    if (binVal == 0) //(0)b
    {
        synElVal = 0; //0 (B_Direct_16x16)
    }
    else //if (binVal == 1) //(1)b
    {
        ctxIdx = ctxIdxOffset + 3; //Table 9-39
        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 1; b1=binVal;
        RETURN_IF_FAILED(ret != 0, -1);

        if (binVal == 0) //(10)b //b1=0
        {
            ctxIdx = ctxIdxOffset + 5; //(b1 != 0) ? 4: 5; b1=0; //Table 9-41 //2,3 (clause 9.3.3.1.2)
            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 2;
            RETURN_IF_FAILED(ret != 0, -1);

            if (binVal == 0) //(100)b
            {
                synElVal = 1; //1 (B_L0_16x16)
            }
            else //if (binVal == 1) //(101)b
            {
                synElVal = 2; //2 (B_L1_16x16)
            }
        }
        else //if (binVal == 1) //(11)b //b1=1
        {
            ctxIdx = ctxIdxOffset + 4; //(b1 != 0) ? 4: 5; b1=1; //Table 9-41 //2,3 (clause 9.3.3.1.2)
            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 2;
            RETURN_IF_FAILED(ret != 0, -1);

            if (binVal == 0) //(110)b
            {
                ctxIdx = ctxIdxOffset + 5; //Table 9-39
                ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 3;
                RETURN_IF_FAILED(ret != 0, -1);
                
                if (binVal == 0) //(1100)b
                {
                    ctxIdx = ctxIdxOffset + 5; //Table 9-39
                    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 4;
                    RETURN_IF_FAILED(ret != 0, -1);
                    
                    if (binVal == 0) //(11000)b
                    {
                        ctxIdx = ctxIdxOffset + 5; //Table 9-39
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(110000)b
                        {
                            synElVal = 3; //3 (B_Bi_16x16)
                        }
                        else //if (binVal == 1) //(110001)b
                        {
                            synElVal = 4; //4 (B_L0_L0_16x8)
                        }
                    }
                    else //if (binVal == 1) //(11001)b
                    {
                        ctxIdx = ctxIdxOffset + 5; //Table 9-39
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(110010)b
                        {
                            synElVal = 5; //5 (B_L0_L0_8x16)
                        }
                        else //if (binVal == 1) //(110011)b
                        {
                            synElVal = 6; //6 (B_L1_L1_16x8)
                        }
                    }
                }
                else //if (binVal == 1) //(1101)b
                {
                    ctxIdx = ctxIdxOffset + 5; //Table 9-39
                    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 4;
                    RETURN_IF_FAILED(ret != 0, -1);
                    
                    if (binVal == 0) //(11010)b
                    {
                        ctxIdx = ctxIdxOffset + 5; //Table 9-39
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(110100)b
                        {
                            synElVal = 7; //7 (B_L1_L1_8x16)
                        }
                        else //if (binVal == 1) //(110101)b
                        {
                            synElVal = 8; //8 (B_L0_L1_16x8)
                        }
                    }
                    else //if (binVal == 1) //(11011)b
                    {
                        ctxIdx = ctxIdxOffset + 5; //Table 9-39
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(110110)b
                        {
                            synElVal = 9; //9 (B_L0_L1_8x16)
                        }
                        else //if (binVal == 1) //(110111)b
                        {
                            synElVal = 10; //10 (B_L1_L0_16x8)
                        }
                    }
                }
            }
            else //if (binVal == 1) //(111)b
            {
                ctxIdx = ctxIdxOffset + 5; //Table 9-39
                ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 3;
                RETURN_IF_FAILED(ret != 0, -1);
                
                if (binVal == 0) //(1110)b
                {
                    ctxIdx = ctxIdxOffset + 5; //Table 9-39
                    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 4;
                    RETURN_IF_FAILED(ret != 0, -1);
                    
                    if (binVal == 0) //(11100)b
                    {
                        ctxIdx = ctxIdxOffset + 5; //Table 9-39
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(111000)b
                        {
                            ctxIdx = ctxIdxOffset + 5; //Table 9-39
                            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 6;
                            RETURN_IF_FAILED(ret != 0, -1);

                            if (binVal == 0) //(1110000)b
                            {
                                synElVal = 12; //12 (B_L0_Bi_16x8)
                            }else //if (binVal == 1) //(1110001)b
                            {
                                synElVal = 13; //13 (B_L0_Bi_8x16)
                            }
                        }
                        else //if (binVal == 1) //(111001)b
                        {
                            ctxIdx = ctxIdxOffset + 5; //Table 9-39
                            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 6;
                            RETURN_IF_FAILED(ret != 0, -1);

                            if (binVal == 0) //(1110010)b
                            {
                                synElVal = 14; //14 (B_L1_Bi_16x8)
                            }else //if (binVal == 1) //(1110011)b
                            {
                                synElVal = 15; //15 (B_L1_Bi_8x16)
                            }
                        }
                    }
                    else //if (binVal == 1) //(11101)b
                    {
                        ctxIdx = ctxIdxOffset + 5; //Table 9-39
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);
                        
                        if (binVal == 0) //(111010)b
                        {
                            ctxIdx = ctxIdxOffset + 5; //Table 9-39
                            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 6;
                            RETURN_IF_FAILED(ret != 0, -1);

                            if (binVal == 0) //(1110100)b
                            {
                                synElVal = 16; //16 (B_Bi_L0_16x8)
                            }else //if (binVal == 1) //(1110101)b
                            {
                                synElVal = 17; //17 (B_Bi_L0_8x16)
                            }
                        }
                        else //if (binVal == 1) //(111011)b
                        {
                            ctxIdx = ctxIdxOffset + 5; //Table 9-39
                            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 6;
                            RETURN_IF_FAILED(ret != 0, -1);

                            if (binVal == 0) //(1110110)b
                            {
                                synElVal = 18; //18 (B_Bi_L1_16x8)
                            }else //if (binVal == 1) //(1110111)b
                            {
                                synElVal = 19; //19 (B_Bi_L1_8x16)
                            }
                        }
                    }
                }
                else //if (binVal == 1) //(1111)b
                {
                    ctxIdx = ctxIdxOffset + 5; //Table 9-39
                    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 4;
                    RETURN_IF_FAILED(ret != 0, -1);
                    
                    if (binVal == 0) //(11110)b
                    {
                        ctxIdx = ctxIdxOffset + 5; //Table 9-39
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(111100)b
                        {
                            ctxIdx = ctxIdxOffset + 5; //Table 9-39
                            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 6;
                            RETURN_IF_FAILED(ret != 0, -1);

                            if (binVal == 0) //(1111000)b
                            {
                                synElVal = 20; //20 (B_Bi_Bi_16x8)
                            }else //if (binVal == 1) //(1111001)b
                            {
                                synElVal = 21; //21 (B_Bi_Bi_8x16)
                            }
                        }
                        else //if (binVal == 1) //(111101)b
                        {
                            //23 to 48 (Intra, prefix only)
                            
                            //------Table 9-34: ctxIdxOffset-suffix: 32--------
                            maxBinIdxCtx = 5;
                            ctxIdxOffset = 32;

                            ret = CABAC_decode_mb_type_in_I_slices(picture, bs, ctxIdxOffset, synElVal);
                            RETURN_IF_FAILED(ret != 0, -1);

                            //For I macroblock types in B slices (mb_type values 23 to 48) the binarization 
                            //consists of bin strings specified as a concatenation of a prefix bit string as 
                            //specified in Table 9-37 and suffix bit strings as specified in Table 9-36, 
                            //indexed by subtracting 23 from the value of mb_type.
                            synElVal += 23;
                        }
                    }
                    else //if (binVal == 1) //(11111)b
                    {
                        ctxIdx = ctxIdxOffset + 5; //Table 9-39
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);

                        if (binVal == 0) //(111110)b
                        {
                            synElVal = 11; //11 (B_L1_L0_8x16)
                        }
                        else //if (binVal == 1) //(111111)b
                        {
                            synElVal = 22; //22 (B_8x8)
                        }
                    }
                }
            }
        }
    }

    return 0;
}


int CH264Cabac::CABAC_decode_sub_mb_type_in_P_SP_slices(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;
    
    H264_SLIECE_TYPE slice_type = (H264_SLIECE_TYPE)picture.m_h264_slice_header.slice_type;
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    RETURN_IF_FAILED((slice_type % 5) != H264_SLIECE_TYPE_P && (slice_type % 5) != H264_SLIECE_TYPE_SP, -1);

    //------Table 9-34: ctxIdxOffset: 21--------
    maxBinIdxCtx = 2;
    ctxIdxOffset = 21;

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1

    ctxIdx = ctxIdxOffset + 0; //ctxIdxOffset + ctxIdxInc = 21 + 0;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);
    
    if (binVal == 1) //(1)b
    {
        synElVal = 0; //0 (P_L0_8x8)
    }
    else if (binVal == 0) //(0)b
    {
        ctxIdx = ctxIdxOffset + 1; //Table 9-39
        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 1;
        RETURN_IF_FAILED(ret != 0, -1);

        if (binVal == 0) //(00)b //b1=0
        {
            synElVal = 1; //1 (P_L0_8x4)
        }
        else //if (binVal == 1) //(01)b //b1=1
        {
            ctxIdx = ctxIdxOffset + 2; //Table 9-39
            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 2;
            RETURN_IF_FAILED(ret != 0, -1);

            if (binVal == 1) //(011)b
            {
                synElVal = 2; //2 (P_L0_4x8)
            }
            else //if (binVal == 0) //(010)b
            {
                synElVal = 3; //3 (P_L0_4x4)
            }
        }
    }

    return 0;
}


int CH264Cabac::CABAC_decode_sub_mb_type_in_B_slices(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;
    
    H264_SLIECE_TYPE slice_type = (H264_SLIECE_TYPE)picture.m_h264_slice_header.slice_type;
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    RETURN_IF_FAILED((slice_type % 5) != H264_SLIECE_TYPE_B, -1);

    //------Table 9-34: ctxIdxOffset: 36--------
    maxBinIdxCtx = 3;
    ctxIdxOffset = 36;

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1
    
    ctxIdx = ctxIdxOffset + 0; //ctxIdxOffset + ctxIdxInc = 36 + 0;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);

    if (binVal == 0) //(0)b
    {
        synElVal = 0; //0 (B_Direct_8x8)
    }
    else //if (binVal == 1) //(1)b
    {
        ctxIdx = ctxIdxOffset + 1; //Table 9-39
        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 1; b1=binVal;
        RETURN_IF_FAILED(ret != 0, -1);

        if (binVal == 0) //(10)b //b1=0
        {
            ctxIdx = ctxIdxOffset + 3; //(b1 != 0) ? 2: 3; b1=0; //Table 9-41 //2,3 (clause 9.3.3.1.2)
            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 2;
            RETURN_IF_FAILED(ret != 0, -1);

            if (binVal == 0) //(100)b
            {
                synElVal = 1; //1 (B_L0_8x8)
            }
            else //if (binVal == 1) //(101)b
            {
                synElVal = 2; //2 (B_L1_8x8)
            }
        }
        else //if (binVal == 1) //(11)b //b1=1
        {
            ctxIdx = ctxIdxOffset + 2; //(b1 != 0) ? 2: 3; b1=0; //Table 9-41 //2,3 (clause 9.3.3.1.2)
            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 2;
            RETURN_IF_FAILED(ret != 0, -1);

            if (binVal == 0) //(110)b
            {
                ctxIdx = ctxIdxOffset + 3; //Table 9-39
                ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 3;
                RETURN_IF_FAILED(ret != 0, -1);
                
                if (binVal == 0) //(1100)b
                {
                    ctxIdx = ctxIdxOffset + 3; //Table 9-39
                    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 4;
                    RETURN_IF_FAILED(ret != 0, -1);
                    
                    if (binVal == 0) //(11000)b
                    {
                        synElVal = 3; //3 (B_Bi_8x8)
                    }
                    else //if (binVal == 1) //(11001)b
                    {
                        synElVal = 4; //4 (B_L0_8x4)
                    }
                }
                else //if (binVal == 1) //(1101)b
                {
                    ctxIdx = ctxIdxOffset + 3; //Table 9-39
                    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 4;
                    RETURN_IF_FAILED(ret != 0, -1);
                    
                    if (binVal == 0) //(11010)b
                    {
                        synElVal = 5; //5 (B_L0_4x8)
                    }
                    else //if (binVal == 1) //(11011)b
                    {
                        synElVal = 6; //6 (B_L1_8x4)
                    }
                }
            }
            else //if (binVal == 1) //(111)b
            {
                ctxIdx = ctxIdxOffset + 3; //Table 9-39
                ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 3;
                RETURN_IF_FAILED(ret != 0, -1);
                
                if (binVal == 0) //(1110)b
                {
                    ctxIdx = ctxIdxOffset + 3; //Table 9-39
                    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 4;
                    RETURN_IF_FAILED(ret != 0, -1);
                    
                    if (binVal == 0) //(11100)b
                    {
                        ctxIdx = ctxIdxOffset + 3; //Table 9-39
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);
                        
                        if (binVal == 0) //(111000)b
                        {
                            synElVal = 7; //7 (B_L1_4x8)
                        }
                        else //if (binVal == 1) //(111001)b
                        {
                            synElVal = 8; //8 (B_Bi_8x4)
                        }
                    }
                    else //if (binVal == 1) //(11101)b
                    {
                        ctxIdx = ctxIdxOffset + 3; //Table 9-39
                        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 5;
                        RETURN_IF_FAILED(ret != 0, -1);
                        
                        if (binVal == 0) //(111010)b
                        {
                            synElVal = 9; //9 (B_Bi_4x8)
                        }
                        else //if (binVal == 1) //(111011)b
                        {
                            synElVal = 10; //10 (B_L0_4x4)
                        }
                    }
                }
                else //if (binVal == 1) //(1111)b
                {
                    ctxIdx = ctxIdxOffset + 3; //Table 9-39
                    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 4;
                    RETURN_IF_FAILED(ret != 0, -1);
                    
                    if (binVal == 0) //(11110)b
                    {
                        synElVal = 11; //11 (B_L1_4x4)
                    }
                    else //if (binVal == 1) //(11111)b
                    {
                        synElVal = 12; //12 (B_Bi_4x4)
                    }
                }
            }
        }
    }

    return 0;
}


//-------------------------------------------
int CH264Cabac::CABAC_decode_mb_skip_flag(CH264PictureBase &picture, CBitstream &bs, int32_t _CurrMbAddr, int32_t &synElVal)
{
    int ret = 0;

    H264_SLIECE_TYPE slice_type = (H264_SLIECE_TYPE)picture.m_h264_slice_header.slice_type;
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    //Table 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset
    if ((slice_type % 5) == H264_SLIECE_TYPE_P || (slice_type % 5) == H264_SLIECE_TYPE_SP)
    {
        //------Table 9-34: ctxIdxOffset: 11--------
        maxBinIdxCtx = 0;
        ctxIdxOffset = 11;
    }
    else if ((slice_type % 5) == H264_SLIECE_TYPE_B)
    {
        //------Table 9-34: ctxIdxOffset: 24--------
        maxBinIdxCtx = 0;
        ctxIdxOffset = 24;
    }
    else
    {
        RETURN_IF_FAILED(-1, -1);
    }

    //9.3.2.4 Fixed-length (FL) binarization process即固定长度二值化
    //FL binarization is constructed by using a fixedLength-bit unsigned integer bin string of the syntax element value, 
    //where fixedLength = Ceil( Log2( cMax + 1 ) ). The indexing of bins for the FL binarization is such that the binIdx = 0 
    //relates to the least significant bit with increasing values of binIdx towards the most significant bit.

    //0,1,2 (clause 9.3.3.1.1.1)
    //9.3.3.1.1.1 Derivation process of ctxIdxInc for the syntax element mb_skip_flag
    ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_skip_flag(picture, _CurrMbAddr, ctxIdxInc);
    RETURN_IF_FAILED(ret != 0, ret);

    //---------------注意是：FL, cMax=1------------------------
    ctxIdx = ctxIdxOffset + ctxIdxInc;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);

    //fixedLength = Ceil( Log2( cMax + 1 ) ) = Ceil( Log2( 1 + 1 ) ) = 1;
    synElVal = binVal;

    return 0;
}


int CH264Cabac::CABAC_decode_mvd_lX(CH264PictureBase &picture, CBitstream &bs, int32_t mvd_flag, int32_t mbPartIdx, int32_t subMbPartIdx, int32_t isChroma, int32_t &synElVal)
{
    int ret = 0;

    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;
    const int32_t uCoff = 9;

    //Table 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset
    //------Table 9-34: ctxIdxOffset-prefix: --------
    if (mvd_flag == 0 //mvd_l0[ ][ ][ 0 ]
        || mvd_flag == 2 //mvd_l1[ ][ ][ 0 ]
       )
    {
        maxBinIdxCtx = 4;
        ctxIdxOffset = 40;
    }
    else //if (mvd_flag == 1 //mvd_l0[ ][ ][ 1 ]
            //|| mvd_flag == 3 //mvd_l1[ ][ ][ 1 ]
            //)
    {
        maxBinIdxCtx = 4;
        ctxIdxOffset = 47;
    }

    //A UEGk bin string is a concatenation of a prefix bit string and a suffix bit string. The prefix of the binarization 
    //is specified by invoking the TU binarization process for the prefix part Min( uCoff, Abs( synElVal ) ) of a syntax 
    //element value synElVal as specified in clause 9.3.2.2 with cMax = uCoff, where uCoff > 0.

    //prefix and suffix as given by UEG3 with signedValFlag=1, uCoff=9

    //9.3.3.1.1.7 Derivation process of ctxIdxInc for the syntax elements mvd_l0 and mvd_l1
    int32_t is_mvd_10 = (mvd_flag == 0 || mvd_flag == 1) ? 1 : 0;
    ret = Derivation_process_of_ctxIdxInc_for_the_syntax_elements_mvd_l0_and_mvd_l1(picture, is_mvd_10, mbPartIdx, subMbPartIdx, 
                isChroma, ctxIdxOffset, ctxIdxInc);
    RETURN_IF_FAILED(ret != 0, ret);

    //---------------注意是：UEG3------------------------
    //UEG3编码是由 prefix(TU binarization) + suffix(Exp-Golomb) + signedValFlag, 三部分组成

    //-----1. 先解码前缀(TU)--------
    ctxIdx = ctxIdxOffset + ctxIdxInc;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);

    //If one of the following is true, the bin string of a syntax element having value synElVal consists only of a prefix bit string:
    // – signedValFlag is equal to 0 and the prefix bit string is not equal to the bit string of length uCoff with all bits equal to 1,
    // – signedValFlag is equal to 1 and the prefix bit string is equal to the bit string that consists of a single bit with value equal to 0.
    if (binVal == 0) //signedValFlag=1
    {
        synElVal = 0; //synElVal consists only of a prefix bit string
    }
    else
    {
        synElVal = 1;
        ctxIdx = ctxIdxOffset + 3; //ctxIdxOffset + ctxIdxInc = 40(47) + 3; //Table 9-39

        //TU, cMax=uCoff=9;
        while (binVal == 1 && synElVal < uCoff) //(11...1)b
        {
            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 1,2,3,4.,..,k;
            RETURN_IF_FAILED(ret != 0, -1);
            
            if (binVal == 0)
            {
                break;
            }
            
            synElVal++;
            
            if (synElVal <= 4) //binIdx=[0,1,2,3,4,5,6,7,8] --> ctxIdxInc= [?,3,4,5,6,6,6,6,6]
            {
                ctxIdx++; //ctxIdx = ctxIdxOffset + ctxIdxInc = 40(47) + [?,3,4,5,6,6,6,6,6]; //Table 9-39
            }
        }

        //-----2. 再解码后缀(Exp-Golomb)--------
        //注意：9.3.2.3 Concatenated unary/ k-th order Exp-Golomb (UEGk) binarization process 中的伪代码表示是UEGk的编码过程，解码需要逆向过来
        //重点是：此处的 Exp-Golomb 和9.1 Parsing process for Exp-Golomb codes中的意思不一样（子曰：这是一个坑）

        //------Table 9-34: ctxIdxOffset-suffix: na (uses DecodeBypass)--------
        int32_t k = 3; //k取值为UEG3中的3

        if (synElVal >= uCoff) //if ( Abs( synElVal ) >= uCoff ) //uCoff=9
        {
            ret = DecodeBypass(bs, binVal);
            RETURN_IF_FAILED(ret != 0, ret);

            while(binVal == 1)
            {
                synElVal += 1 << k;
                ++k;
                RETURN_IF_FAILED(k >= 32 - uCoff, ret); //error: mv值过大
                
                ret = DecodeBypass(bs, binVal);
                RETURN_IF_FAILED(ret != 0, ret);
            }
            
            while( k-- )
            {
                ret = DecodeBypass(bs, binVal);
                RETURN_IF_FAILED(ret != 0, ret);

                synElVal += binVal << k;
            }
        }

        if (synElVal != 0) //if ( signedValFlag && synElVal ! = 0) //signedValFlag=1代表结果是有符号整数
        {
            ret = DecodeBypass(bs, binVal);
            RETURN_IF_FAILED(ret != 0, ret);

            if (binVal == 1)
            {
                synElVal = -synElVal; //结果为负数
            }
        }
    }

    return 0;
}


int CH264Cabac::CABAC_decode_ref_idx_lX(CH264PictureBase &picture, CBitstream &bs, int32_t ref_idx_flag, int32_t mbPartIdx, int32_t &synElVal)
{
    int ret = 0;

    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    //Table 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset
    //------Table 9-34: ctxIdxOffset: 54--------
    maxBinIdxCtx = 2;
    ctxIdxOffset = 54;

    //0,1,2,3 (clause 9.3.3.1.1.6)
    int32_t is_ref_idx_10 = (ref_idx_flag == 0) ? 1 : 0;
    ret = Derivation_process_of_ctxIdxInc_for_the_syntax_elements_ref_idx_l0_and_ref_idx_l1(picture, is_ref_idx_10, mbPartIdx, ctxIdxInc);
    RETURN_IF_FAILED(ret != 0, ret);
    
    //---------------注意是：U binarization------------------------
    ctxIdx = ctxIdxOffset + ctxIdxInc;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);

    //unary (U) binarization即一元二值化，就是类似 (111...1110)b 这样的二进制字符串，最后一个二进制值为0，其他都是1，其中1的个数就是对应的语法元素的值
    
    //binIdx=[0,1,2,3,4,5,6,...,k] --> ctxIdx = ctxIdxOffset + ctxIdxInc = 54 + [?,4,5,5,5,5,5,...,5]

    if (binVal == 0) //(0)b
    {
        synElVal = 0;
    }
    else //if (binVal == 1) //(1)b
    {
        ctxIdx = ctxIdxOffset + 4; //Table 9-39
        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 1;
        RETURN_IF_FAILED(ret != 0, -1);

        binIdx = 1;
        ctxIdx = ctxIdxOffset + 5; //Table 9-39

        while(binVal == 1) //(11...1)b
        {
            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 2,3,4.,..,k;
            RETURN_IF_FAILED(ret != 0, -1);

            binIdx++;

            RETURN_IF_FAILED(binIdx > 32, -1); //error: ref_idx 值太大了
        }

        synElVal = binIdx;
    }

    return 0;
}


int CH264Cabac::CABAC_decode_mb_qp_delta(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;
    
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;
    int32_t bit_depth_luma = 8;

    //------Table 9-34: ctxIdxOffset: 60--------
    maxBinIdxCtx = 2;
    ctxIdxOffset = 60;

    //9.3.2.7 Binarization process for mb_qp_delta
    //The bin string of mb_qp_delta is derived by the U binarization of the mapped value of the syntax element mb_qp_delta, where the 
    //assignment rule between the signed value of mb_qp_delta and its mapped value is given as specified in Table 9-3.

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1

    //0,1 (clause 9.3.3.1.1.5)
    //9.3.3.1.1.5 Derivation process of ctxIdxInc for the syntax element mb_qp_delta
    ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_qp_delta(picture, ctxIdxInc);
    RETURN_IF_FAILED(ret != 0, ret);
    
    //---------------注意是：U binarization------------------------
    ctxIdx = ctxIdxOffset + ctxIdxInc;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);

    //unary (U) binarization即一元二值化，就是类似 (111...1110)b 这样的二进制字符串，最后一个二进制值为0，其他都是1，其中1的个数就是对应的语法元素的值
    if (binVal == 0) //(0)b
    {
        synElVal = 0;
    }
    else //if (binVal == 1) //(1)b
    {
        ctxIdx = ctxIdxOffset + 2; //Table 9-39
        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 1;
        RETURN_IF_FAILED(ret != 0, -1);

        int mb_qp_max = 51 + 6 * (bit_depth_luma - 8);
        binIdx = 1;

        while(binVal == 1) //(11...1)b
        {
            ctxIdx = ctxIdxOffset + 3; //Table 9-39
            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 2,3,4.,..,k;
            RETURN_IF_FAILED(ret != 0, -1);

            binIdx++;

            RETURN_IF_FAILED(binIdx > 2 * mb_qp_max, -1); //error: mb_qp_delta值太大了
        }

        //----------Table 9-3 se(v)-------------
        if (binIdx & 0x01) //奇数
        {
            binIdx = (binIdx + 1) >> 1; //(−1)^(k+1) * Ceil(k÷2)
        }
        else //偶数
        {
            binIdx = -((binIdx + 1) >> 1); //(−1)^(k+1) * Ceil(k÷2)
        }

        synElVal = binIdx;
    }
    
    return 0;
}


int CH264Cabac::CABAC_decode_intra_chroma_pred_mode(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;
    
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    //------Table 9-34: ctxIdxOffset: 64--------
    maxBinIdxCtx = 1;
    ctxIdxOffset = 64;

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1

    //0,1,2 (clause 9.3.3.1.1.8)
    //9.3.3.1.1.8 Derivation process of ctxIdxInc for the syntax element intra_chroma_pred_mode
    ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_intra_chroma_pred_mode(picture, ctxIdxInc);
    RETURN_IF_FAILED(ret != 0, ret);
    
    //---------------注意是：TU, cMax=3------------------------
    ctxIdx = ctxIdxOffset + ctxIdxInc;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);

    if (binVal == 0) //(0)b
    {
        synElVal = 0;
    }
    else //if (binVal == 1) //(1)b
    {
        ctxIdx = ctxIdxOffset + 3; //Table 9-39
        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 1;
        RETURN_IF_FAILED(ret != 0, -1);

        if (binVal == 0) //(10)b
        {
            synElVal = 1;
        }
        else //if (binVal == 1) //(11)b
        {
            ctxIdx = ctxIdxOffset + 3; //Table 9-39
            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 2;
            RETURN_IF_FAILED(ret != 0, -1);

            if (binVal == 0) //(110)b
            {
                synElVal = 2;
            }
            else //if (binVal == 1) //(111)b
            {
                //9.3.2.2 Truncated unary (TU) binarization process
                //the syntax element value equal to cMax the bin string is a bit string of length cMax with all bins being equal to 1.
                synElVal = 3; //TU, cMax=3
            }
        }
    }
    
    return 0;
}


int CH264Cabac::CABAC_decode_prev_intra4x4_pred_mode_flag_or_prev_intra8x8_pred_mode_flag(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;
    
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    //------Table 9-34: ctxIdxOffset: 68--------
    maxBinIdxCtx = 0;
    ctxIdxOffset = 68;

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1

    //---------------注意是：FL, cMax=1------------------------
    ctxIdx = ctxIdxOffset + 0; //ctxIdxInc = 0;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);
    
    //fixedLength = Ceil( Log2( cMax + 1 ) ) = Ceil( Log2( 1 + 1 ) ) = 1;
    synElVal = binVal;
    
    return 0;
}


int CH264Cabac::CABAC_decode_rem_intra4x4_pred_mode_or_rem_intra8x8_pred_mode(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;
    
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    //------Table 9-34: ctxIdxOffset: 69--------
    maxBinIdxCtx = 0;
    ctxIdxOffset = 69;

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1
    
    //binIdx=[0,1,2] --> ctxIdx = ctxIdxOffset + ctxIdxInc = 69 + [0,0,0]

    //---------------注意是：FL, cMax=7------------------------
    ctxIdx = ctxIdxOffset + 0; //ctxIdxInc = 0;
    
    //fixedLength = Ceil( Log2( cMax + 1 ) ) = Ceil( Log2( 7 + 1 ) ) = 3;

    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);
    synElVal = binVal;
    
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 1;
    RETURN_IF_FAILED(ret != 0, -1);
    synElVal += binVal << 1;

    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 2;
    RETURN_IF_FAILED(ret != 0, -1);
    synElVal += binVal << 2;
    
    return 0;
}


int CH264Cabac::CABAC_decode_mb_field_decoding_flag(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;
    
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    //------Table 9-34: ctxIdxOffset: 70--------
    maxBinIdxCtx = 0;
    ctxIdxOffset = 70;

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1

    //0,1,2 (clause 9.3.3.1.1.2)
    ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_field_decoding_flag(picture, ctxIdxInc);
    RETURN_IF_FAILED(ret != 0, ret);

    //---------------注意是：FL, cMax=1------------------------
    ctxIdx = ctxIdxOffset + ctxIdxInc;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);
    
    //fixedLength = Ceil( Log2( cMax + 1 ) ) = Ceil( Log2( 1 + 1 ) ) = 1;
    synElVal = binVal;
    
    return 0;
}


int CH264Cabac::CABAC_decode_coded_block_pattern(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;
    
    int32_t ChromaArrayType = picture.m_h264_slice_header.m_sps.ChromaArrayType;
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t binValues = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    //------Table 9-34: ctxIdxOffset-prefix: 73--------
    maxBinIdxCtx = 3;
    ctxIdxOffset = 73;

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1
    
    //The binarization of coded_block_pattern consists of a prefix part and (when present) a suffix part. The prefix part of the binarization 
    //is given by the FL binarization of CodedBlockPatternLuma with cMax = 15. When ChromaArrayType is not equal to 0 or 3, the suffix part is 
    //present and consists of the TU binarization of CodedBlockPatternChroma with cMax = 2. The relationship between the value of the syntax 
    //element coded_block_pattern and the values of CodedBlockPatternLuma and CodedBlockPatternChroma is given as specified in clause 7.4.5.

    //binIdx=[0,1,2] --> ctxIdx = ctxIdxOffset + ctxIdxInc = 69 + [0,0,0]

    //0,1,2,3 (clause 9.3.3.1.1.4)
    
    //前缀部分CodedBlockPatternLuma：FL, cMax=15
    //fixedLength = Ceil( Log2( cMax + 1 ) ) = Ceil( Log2( 15 + 1 ) ) = 4;

    //------b0--------
    binIdx = 0;
    ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_pattern(picture, binIdx, binValues, ctxIdxOffset, ctxIdxInc);
    RETURN_IF_FAILED(ret != 0, ret);

    ctxIdx = ctxIdxOffset + ctxIdxInc;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);
    
    binValues = binVal;

    //------b1--------
    binIdx = 1;
    ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_pattern(picture, binIdx, binValues, ctxIdxOffset, ctxIdxInc);
    RETURN_IF_FAILED(ret != 0, ret);

    ctxIdx = ctxIdxOffset + ctxIdxInc;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 1;
    RETURN_IF_FAILED(ret != 0, -1);
    
    binValues += binVal << 1;
    
    //------b2--------
    binIdx = 2;
    ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_pattern(picture, binIdx, binValues, ctxIdxOffset, ctxIdxInc);
    RETURN_IF_FAILED(ret != 0, ret);

    ctxIdx = ctxIdxOffset + ctxIdxInc;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 2;
    RETURN_IF_FAILED(ret != 0, -1);
    
    binValues += binVal << 2;
    
    //------b3--------
    binIdx = 3;
    ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_pattern(picture, binIdx, binValues, ctxIdxOffset, ctxIdxInc);
    RETURN_IF_FAILED(ret != 0, ret);

    ctxIdx = ctxIdxOffset + ctxIdxInc;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 3;
    RETURN_IF_FAILED(ret != 0, -1);
    
    binValues += binVal << 3;
    
    int32_t CodedBlockPatternLuma = binValues; //[0,15]
    
    //------Table 9-34: ctxIdxOffset-suffix: 77--------
    //后缀部分CodedBlockPatternChroma：TU, cMax=2

    int32_t CodedBlockPatternChroma = 0; //0,1,2

    if (ChromaArrayType != 0 && ChromaArrayType != 3)
    {
        //TU binarization, cMax = 2
        maxBinIdxCtx = 1;
        ctxIdxOffset = 77;
        binValues = 0;
        
        binIdx = 0;
        ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_pattern(picture, binIdx, binValues, ctxIdxOffset, ctxIdxInc);
        RETURN_IF_FAILED(ret != 0, ret);

        ctxIdx = ctxIdxOffset + ctxIdxInc;
        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
        RETURN_IF_FAILED(ret != 0, -1);

        if (binVal == 0) //(0)b
        {
            CodedBlockPatternChroma = 0;
        }
        else //if (binVal == 1) //(1)b
        {
            CodedBlockPatternChroma = 1;
            
            binIdx = 1;
            ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_pattern(picture, binIdx, binValues, ctxIdxOffset, ctxIdxInc);
            RETURN_IF_FAILED(ret != 0, ret);

            ctxIdx = ctxIdxOffset + ctxIdxInc;
            ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 1;
            RETURN_IF_FAILED(ret != 0, -1);

            if (binVal == 1) //(11)b
            {
                CodedBlockPatternChroma = 2; //cMax = 2
            }
        }
    }

    //CodedBlockPatternLuma = coded_block_pattern % 16;
    //CodedBlockPatternChroma = coded_block_pattern / 16;

    synElVal = CodedBlockPatternLuma + CodedBlockPatternChroma * 16;

    return 0;
}


int CH264Cabac::CABAC_decode_coded_block_flag(CH264PictureBase &picture, CBitstream &bs, MB_RESIDUAL_LEVEL mb_block_level, int32_t BlkIdx, int32_t iCbCr, int32_t &synElVal)
{
    int ret = 0;
    
    int32_t NumC8x8 = 4 / (picture.m_h264_slice_header.m_sps.SubWidthC * picture.m_h264_slice_header.m_sps.SubHeightC);
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;
    int32_t maxNumCoeff = 0;
    int32_t ctxBlockCat = 0;

    //--------1.先计算出ctxBlockCat的值------------
    //Table 9-42 – Specification of ctxBlockCat for the different blocks
    // ctxBlockCats[][0] = ctxBlockCat;
    // ctxBlockCats[][1] = maxNumCoeff;
    int32_t ctxBlockCats[14][2] = 
    {
        {0, 16}, //MB_RESIDUAL_Intra16x16DCLevel
        {1, 15}, //MB_RESIDUAL_Intra16x16ACLevel
        {2, 16}, //MB_RESIDUAL_LumaLevel4x4
        {3, 4 * NumC8x8}, //MB_RESIDUAL_ChromaDCLevel
        {4, 15}, //MB_RESIDUAL_ChromaACLevel
        {5, 64}, //MB_RESIDUAL_LumaLevel8x8
        {6, 16}, //MB_RESIDUAL_CbIntra16x16DCLevel
        {7, 15}, //MB_RESIDUAL_CbIntra16x16ACLevel
        {8, 16}, //MB_RESIDUAL_CbLevel4x4
        {9, 64}, //MB_RESIDUAL_CbLevel8x8
        {10, 16}, //MB_RESIDUAL_CrIntra16x16DCLevel
        {11, 15}, //MB_RESIDUAL_CrIntra16x16ACLevel
        {12, 16}, //MB_RESIDUAL_CrLevel4x4
        {13, 64}, //MB_RESIDUAL_CrLevel8x8
    };

    //ctxBlockCat = ctxBlockCats[mb_block_level][0];
    //maxNumCoeff = ctxBlockCats[mb_block_level][1];

    ctxBlockCat = mb_block_level;

    //--------2.获取ctxIdxOffset的值-----------
    //Table 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset
    maxBinIdxCtx = 0;
    if (ctxBlockCat < 5) //(blocks with ctxBlockCat < 5) FL, cMax=1
    {
        ctxIdxOffset = 85;
    }
    else if (ctxBlockCat > 5 && ctxBlockCat < 9)
    {
        ctxIdxOffset = 460;
    }
    else if (ctxBlockCat > 9 && ctxBlockCat < 13)
    {
        ctxIdxOffset = 472;
    }
    else //if (ctxBlockCat == 5 || ctxBlockCat == 9 || ctxBlockCat == 13)
    {
        ctxIdxOffset = 1012;
    }

    //Table 9-40 – Assignment of ctxIdxBlockCatOffset to ctxBlockCat for syntax elements coded_block_flag, significant_coeff_flag, 
    //last_significant_coeff_flag, and coeff_abs_level_minus1

     const int32_t ctxIdxBlockCatOffset_arr[14] = {0, 4, 8, 12, 16, 0, 0, 4, 8, 4, 0, 4, 8, 8};
     int32_t ctxIdxBlockCatOffset = ctxIdxBlockCatOffset_arr[ctxBlockCat];
    
    //9.3.3.1.1.9
    ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_flag(picture, ctxBlockCat, BlkIdx, iCbCr, ctxIdxInc);
    RETURN_IF_FAILED(ret != 0, -1);
    
    //--------3.计算出ctxIdx的值-----------
    //the ctxIdx is specified to be the sum of the following terms: ctxIdxOffset and 
    //ctxIdxBlockCatOffset(ctxBlockCat) as specified in Table 9-40 and ctxIdxInc(ctxBlockCat).

    ctxIdx = ctxIdxOffset + ctxIdxBlockCatOffset + ctxIdxInc;
    
    //--------4.进行处理 FL, cMax=1-----------
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);
    
    //fixedLength = Ceil( Log2( cMax + 1 ) ) = Ceil( Log2( 1 + 1 ) ) = 1;
    synElVal = binVal;
    
    return 0;
}


//如果last_flag=1,则表示 CABAC_decode_last_significant_coeff_flag(...)
int CH264Cabac::CABAC_decode_significant_coeff_flag(CH264PictureBase &picture, CBitstream &bs, MB_RESIDUAL_LEVEL mb_block_level, 
                    int32_t levelListIdx, int32_t last_flag, int32_t &synElVal)
{
    int ret = 0;
    
    int32_t NumC8x8 = 4 / (picture.m_h264_slice_header.m_sps.SubWidthC * picture.m_h264_slice_header.m_sps.SubHeightC);
    int32_t mb_field_decoding_flag = picture.m_mbs[picture.CurrMbAddr].mb_field_decoding_flag;
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;
    int32_t maxNumCoeff = 0;
    int32_t ctxBlockCat = 0;

    //--------1.先计算出ctxBlockCat的值------------
    //Table 9-42 – Specification of ctxBlockCat for the different blocks
    
    ctxBlockCat = mb_block_level;

    //--------2.获取ctxIdxOffset的值-----------
    //Table 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset
    maxBinIdxCtx = 0;
    if (ctxBlockCat < 5) //(frame coded blocks with ctxBlockCat < 5) FL, cMax=1
    {
        if (last_flag == 0) //significant_coeff_flag
        {
            ctxIdxOffset = (mb_field_decoding_flag == 0) ? 105 : 277;
        }
        else //last_significant_coeff_flag
        {
            ctxIdxOffset = (mb_field_decoding_flag == 0) ? 166 : 338;
        }
    }
    else if (ctxBlockCat == 5)
    {
        if (last_flag == 0) //significant_coeff_flag
        {
            ctxIdxOffset = (mb_field_decoding_flag == 0) ? 402 : 436;
        }
        else //last_significant_coeff_flag
        {
            ctxIdxOffset = (mb_field_decoding_flag == 0) ? 417 : 451;
        }
    }
    else if (ctxBlockCat > 5 && ctxBlockCat < 9)
    {
        if (last_flag == 0) //significant_coeff_flag
        {
            ctxIdxOffset = (mb_field_decoding_flag == 0) ? 484 : 776;
        }
        else //last_significant_coeff_flag
        {
            ctxIdxOffset = (mb_field_decoding_flag == 0) ? 572 : 864;
        }
    }
    else if (ctxBlockCat > 9 && ctxBlockCat < 13)
    {
        if (last_flag == 0) //significant_coeff_flag
        {
            ctxIdxOffset = (mb_field_decoding_flag == 0) ? 528 : 820;
        }
        else //last_significant_coeff_flag
        {
            ctxIdxOffset = (mb_field_decoding_flag == 0) ? 616 : 908;
        }
    }
    else if (ctxBlockCat == 9)
    {
        if (last_flag == 0) //significant_coeff_flag
        {
            ctxIdxOffset = (mb_field_decoding_flag == 0) ? 660 : 675;
        }
        else //last_significant_coeff_flag
        {
            ctxIdxOffset = (mb_field_decoding_flag == 0) ? 690 : 699;
        }
    }
    else //if (ctxBlockCat == 13)
    {
        if (last_flag == 0) //significant_coeff_flag
        {
            ctxIdxOffset = (mb_field_decoding_flag == 0) ? 718 : 733;
        }
        else //last_significant_coeff_flag
        {
            ctxIdxOffset = (mb_field_decoding_flag == 0) ? 748 : 757;
        }
    }

    //Table 9-40 – Assignment of ctxIdxBlockCatOffset to ctxBlockCat for syntax elements coded_block_flag, significant_coeff_flag, 
    //last_significant_coeff_flag, and coeff_abs_level_minus1
    
     const int32_t ctxIdxBlockCatOffset_arr[14] = {0, 15, 29, 44, 47, 0, 0, 15, 29, 0, 0, 15, 29, 0};
     int32_t ctxIdxBlockCatOffset = ctxIdxBlockCatOffset_arr[ctxBlockCat];

    //9.3.3.1.3 Assignment process of ctxIdxInc for syntax elements significant_coeff_flag, last_significant_coeff_flag
    //Let the variable levelListIdx be set equal to the index of the list of transform coefficient levels as specified in clause 7.4.5.3.
    
    //------------------------------
    if (ctxBlockCat != 3
        && ctxBlockCat != 5
        && ctxBlockCat != 9
        && ctxBlockCat != 13
       )
    {
        //RETURN_IF_FAILED(levelListIdx < 0 || levelListIdx > maxNumCoeff - 2, -1);

        ctxIdxInc = levelListIdx; //levelListIdx ranges from 0 to maxNumCoeff - 2, inclusive.
    }
    else if (ctxBlockCat == 3)
    {
        RETURN_IF_FAILED(levelListIdx < 0 || levelListIdx > 4 * NumC8x8 - 2, -1);

        ctxIdxInc = MIN( levelListIdx / NumC8x8, 2 ); //levelListIdx ranges from 0 to 4 * NumC8x8 - 2, inclusive
    }
    else if (ctxBlockCat == 5 || ctxBlockCat == 9 || ctxBlockCat == 13)
    {
        //Table 9-43 – Mapping of scanning position to ctxIdxInc for ctxBlockCat = = 5, 9, or 13

        //ctxIdxInc_coeff[i][levelListIdx=0] = ctxIdxInc for significant_coeff_flag (frame coded macroblocks)
        //ctxIdxInc_coeff[i][levelListIdx=1] = ctxIdxInc for significant_coeff_flag (field coded macroblocks)
        //ctxIdxInc_coeff[i][levelListIdx=2] = ctxIdxInc for last_significant_coeff_flag

        const int32_t ctxIdxInc_coeff[63][3] = 
        {
            {0, 0, 0}, {1, 1, 1}, {2, 1, 1}, {3, 2, 1}, {4, 2, 1}, {5, 3, 1}, {5, 3, 1}, {4, 4, 1}, {4, 5, 1}, {3, 6, 1},
            {3, 7, 1}, {4, 7, 1}, {4, 7, 1}, {4, 8, 1}, {5, 4, 1}, {5, 5, 1}, {4, 6, 2}, {4, 9, 2}, {4, 10, 2}, {4, 10, 2},
            {3, 8, 2}, {3, 11, 2}, {6, 12, 2}, {7, 11, 2}, {7, 9, 2}, {7, 9, 2}, {8, 10, 2}, {9, 10, 2}, {10, 8, 2}, {9, 11, 2},
            {8, 12, 2}, {7, 11, 2}, {7, 9, 3}, {6, 9, 3}, {11, 10, 3}, {12, 10, 3}, {13, 8, 3}, {11, 11, 3}, {6, 12, 3}, {7, 11, 3},
            {8, 9, 4}, {9, 9, 4}, {14, 10, 4}, {10, 10, 4}, {9, 8, 4}, {8, 13, 4}, {6, 13, 4}, {11, 9, 4}, {12, 9, 5}, {13, 10, 5},
            {11, 10, 5}, {6, 8, 5}, {9, 13, 6}, {14, 13, 6}, {10, 9, 6}, {9, 9, 6}, {11, 10, 7}, {12, 10, 7}, {13, 14, 7}, {11, 14, 7},
            {14, 14, 8}, {10, 14, 8}, {12, 14, 8}
        };
        
        RETURN_IF_FAILED(levelListIdx < 0 || levelListIdx > 63, -1);

        if (last_flag == 0) //significant_coeff_flag
        {
            ctxIdxInc = ctxIdxInc_coeff[levelListIdx][mb_field_decoding_flag];
        }
        else //last_significant_coeff_flag
        {
            ctxIdxInc = ctxIdxInc_coeff[levelListIdx][2];
        }
    }
    
    //--------3.计算出ctxIdx的值-----------
    //the ctxIdx is specified to be the sum of the following terms: ctxIdxOffset and 
    //ctxIdxBlockCatOffset(ctxBlockCat) as specified in Table 9-40 and ctxIdxInc(ctxBlockCat).

    ctxIdx = ctxIdxOffset + ctxIdxBlockCatOffset + ctxIdxInc;

    //---------------注意是：FL, cMax=1------------------------
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);
    
    //fixedLength = Ceil( Log2( cMax + 1 ) ) = Ceil( Log2( 1 + 1 ) ) = 1;
    synElVal = binVal;
    
    return 0;
}


int CH264Cabac::CABAC_decode_coeff_abs_level_minus1(CH264PictureBase &picture, CBitstream &bs, MB_RESIDUAL_LEVEL mb_block_level, 
                    int32_t numDecodAbsLevelEq1, int32_t numDecodAbsLevelGt1, int32_t &synElVal)
{
    int ret = 0;
    
    int32_t NumC8x8 = 4 / (picture.m_h264_slice_header.m_sps.SubWidthC * picture.m_h264_slice_header.m_sps.SubHeightC);
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;
    int32_t maxNumCoeff = 0;
    int32_t ctxBlockCat = 0;

    //--------1.先计算出ctxBlockCat的值------------
    //Table 9-42 – Specification of ctxBlockCat for the different blocks

    ctxBlockCat = mb_block_level;

    //--------2.获取ctxIdxOffset-prefix的值-----------
    //prefix and suffix as given by UEG0 with signedValFlag=0, uCoff=14

    //Table 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset
    maxBinIdxCtx = 1;
    if (ctxBlockCat < 5) //(blocks with ctxBlockCat < 5)
    {
        ctxIdxOffset = 227;
    }
    else if (ctxBlockCat == 5)
    {
        ctxIdxOffset = 426;
    }
    else if (ctxBlockCat > 5 && ctxBlockCat < 9)
    {
        ctxIdxOffset = 952;
    }
    else if (ctxBlockCat > 9 && ctxBlockCat < 13)
    {
        ctxIdxOffset = 982;
    }
    else if (ctxBlockCat == 9)
    {
        ctxIdxOffset = 708;
    }
    else //if (ctxBlockCat == 13)
    {
        ctxIdxOffset = 766;
    }

    //Table 9-40 – Assignment of ctxIdxBlockCatOffset to ctxBlockCat for syntax elements coded_block_flag, significant_coeff_flag, 
    //last_significant_coeff_flag, and coeff_abs_level_minus1

    const int32_t ctxIdxBlockCatOffset_arr[14] = {0, 10, 20, 30, 39, 0, 0, 10, 20, 0, 0, 10, 20, 0};
    int32_t ctxIdxBlockCatOffset = ctxIdxBlockCatOffset_arr[ctxBlockCat];
    
    //Let numDecodAbsLevelEq1 denote the accumulated number of decoded transform coefficient levels with absolute value equal to 1, 
    //and let numDecodAbsLevelGt1 denote the accumulated number of decoded transform coefficient levels with absolute value greater 
    //than 1. Both numbers are related to the same transform coefficient block, where the current decoding process takes place.
    //Then, for decoding of coeff_abs_level_minus1, ctxIdxInc for coeff_abs_level_minus1 is specified depending on binIdx as follows:
    //  – If binIdx is equal to 0, ctxIdxInc is derived by
    //       ctxIdxInc = ( ( numDecodAbsLevelGt1 != 0 ) ? 0: Min( 4, 1 + numDecodAbsLevelEq1 ) )
    //  – Otherwise (binIdx is greater than 0), ctxIdxInc is derived by
    //       ctxIdxInc = 5 + Min( 4 − ( ( ctxBlockCat = = 3 ) ? 1 : 0 ), numDecodAbsLevelGt1 )

    ctxIdxInc = ((numDecodAbsLevelGt1 != 0) ? 0 : MIN(4, 1 + numDecodAbsLevelEq1)); //if (binIdx == 0)
    
    //--------3.计算出ctxIdx的值-----------
    //the ctxIdx is specified to be the sum of the following terms: ctxIdxOffset and 
    //ctxIdxBlockCatOffset(ctxBlockCat) as specified in Table 9-40 and ctxIdxInc(ctxBlockCat).

    ctxIdx = ctxIdxOffset + ctxIdxBlockCatOffset + ctxIdxInc;
    
    //--------4.进行处理 UEG0 with signedValFlag=0, uCoff=14-----------
    
    //UEGk编码是由 prefix(TU binarization) + suffix(Exp-Golomb) + signedValFlag, 三部分组成

    //-----4.1. 先解码前缀(TU)--------
    const int32_t uCoff = 14;

    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);
    
    synElVal = 0;
    ctxIdxInc = 5 + MIN(4 - ((ctxBlockCat == 3) ? 1 : 0), numDecodAbsLevelGt1); //if (binIdx > 0)
    ctxIdx = ctxIdxOffset + ctxIdxBlockCatOffset + ctxIdxInc;

    //TU, cMax=uCoff=14;
    while (binVal == 1) //(11...1)b
    {
        synElVal++;
        if (synElVal >= uCoff)
        {
            break;
        }

        ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 1,2,3,4.,..,k;
        RETURN_IF_FAILED(ret != 0, -1);
    }

    //-----4.2. 再解码后缀(Exp-Golomb)--------
    //If one of the following is true, the bin string of a syntax element having value synElVal consists only of a prefix bit string:
    // – signedValFlag is equal to 0 and the prefix bit string is not equal to the bit string of length uCoff with all bits equal to 1,
    // – signedValFlag is equal to 1 and the prefix bit string is equal to the bit string that consists of a single bit with value equal to 0.
    if (synElVal != uCoff) //signedValFlag=0
    {
        //synElVal为prefix(TU)的值 //synElVal consists only of a prefix bit string
    }
    else
    {
        //注意：9.3.2.3 Concatenated unary/ k-th order Exp-Golomb (UEGk) binarization process 中的伪代码表示是UEGk的编码过程，解码需要逆向过来

        //------Table 9-34: ctxIdxOffset-suffix: na (uses DecodeBypass)--------
        int32_t k = 0; //k取值为UEG0中的0

        if (synElVal >= uCoff) //if ( Abs( synElVal ) >= uCoff ) //uCoff=14
        {
            ret = DecodeBypass(bs, binVal);
            RETURN_IF_FAILED(ret != 0, ret);

            while(binVal == 1)
            {
                synElVal += 1 << k;
                ++k;
                RETURN_IF_FAILED(k >= 32 - uCoff, ret); //error: coeff_abs_level_minus1值过大
                
                ret = DecodeBypass(bs, binVal);
                RETURN_IF_FAILED(ret != 0, ret);
            }
            
            while( k-- )
            {
                ret = DecodeBypass(bs, binVal);
                RETURN_IF_FAILED(ret != 0, ret);

                synElVal += binVal << k;
            }
        }

        //signedValFlag=0代表结果是无符号整数，所以不需要处理最后一个符号位
    }
    
    return 0;
}


int CH264Cabac::CABAC_decode_coeff_sign_flag(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;
    
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    //------Table 9-34: ctxIdxOffset: (uses DecodeBypass)--------
    maxBinIdxCtx = 0;
    ctxIdxOffset = -1;

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1

    //---------------注意是：FL, cMax=1------------------------
    ret = DecodeBypass(bs, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);
    
    //fixedLength = Ceil( Log2( cMax + 1 ) ) = Ceil( Log2( 1 + 1 ) ) = 1;
    synElVal = binVal;
    
    return 0;
}


int CH264Cabac::CABAC_decode_end_of_slice_flag(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;
    
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    //------Table 9-34: ctxIdxOffset: 276--------
    maxBinIdxCtx = 0;
    ctxIdxOffset = 276;

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1

    //---------------注意是：FL, cMax=1------------------------
    ctxIdx = ctxIdxOffset + 0; //ctxIdxOffset + ctxIdxInc;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);
    
    //fixedLength = Ceil( Log2( cMax + 1 ) ) = Ceil( Log2( 1 + 1 ) ) = 1;
    synElVal = binVal;
    
    return 0;
}


int CH264Cabac::CABAC_decode_transform_size_8x8_flag(CH264PictureBase &picture, CBitstream &bs, int32_t &synElVal)
{
    int ret = 0;
    
    int32_t maxBinIdxCtx = 0;
    int32_t ctxIdxOffset = 0;
    int32_t ctxIdxInc = 0;
    int32_t binIdx = -1;
    int32_t binVal = 0;
    int32_t ctxIdx = 0;
    int32_t bypassFlag = 0;

    //------Table 9-34: ctxIdxOffset: 399--------
    maxBinIdxCtx = 0;
    ctxIdxOffset = 399;

    //Table 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax elements coded_block_flag, 
    //significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1

    //0,1,2 (clause 9.3.3.1.1.10)
    ret = Derivation_process_of_ctxIdxInc_for_the_syntax_element_transform_size_8x8_flag(picture, ctxIdxInc);
    RETURN_IF_FAILED(ret != 0, -1);

    //---------------注意是：FL, cMax=1------------------------
    ctxIdx = ctxIdxOffset + ctxIdxInc;
    ret = DecodeBin(bs, bypassFlag, ctxIdx, binVal); //binIdx = 0;
    RETURN_IF_FAILED(ret != 0, -1);
    
    //fixedLength = Ceil( Log2( cMax + 1 ) ) = Ceil( Log2( 1 + 1 ) ) = 1;
    synElVal = binVal;
    
    return 0;
}


//-----------------------------------------------
/*
 * T-REC-H.264-201704-S!!PDF-E.pdf
 * Page 62/84/812
 * 7.3.5.3.3 Residual block CABAC syntax
 */
int CH264Cabac::residual_block_cabac(CH264PictureBase &picture, CBitstream &bs, int32_t coeffLevel[], int32_t startIdx, int32_t endIdx, 
                    int32_t maxNumCoeff, MB_RESIDUAL_LEVEL mb_block_level, int32_t BlkIdx, int32_t iCbCr, int32_t &TotalCoeff)
{
    int ret = 0;

    int32_t ChromaArrayType = picture.m_h264_slice_header.m_sps.ChromaArrayType;
    int32_t i = 0;
    int32_t coded_block_flag = 1; //When coded_block_flag is not present, it shall be inferred to be equal to 1.
    int32_t numCoeff = 0;
    int32_t numDecodAbsLevelEq1 = 0;
    int32_t numDecodAbsLevelGt1 = 0;

    int32_t significant_coeff_flag[64] = {0};
    int32_t last_significant_coeff_flag[64] = {0};
    int32_t coeff_abs_level_minus1[64] = {0};
    int32_t coeff_sign_flag[64] = {0};
    int32_t index[64] = {0};
    TotalCoeff = 0;

    if (maxNumCoeff != 64 || ChromaArrayType == 3)
    {
        ret = CABAC_decode_coded_block_flag(picture, bs, mb_block_level, BlkIdx, iCbCr, coded_block_flag); //3 | 4 ae(v)
        RETURN_IF_FAILED(ret != 0, -1);
    }

    //for (i = 0; i < maxNumCoeff; i++) { coeffLevel[ i ] = 0; }
    memset(coeffLevel, 0, sizeof(int32_t) * maxNumCoeff);

    if (coded_block_flag)
    {
        numCoeff = endIdx + 1;

        i = startIdx;

        while (i < numCoeff - 1)
        {
            int32_t & levelListIdx = i;

            ret = CABAC_decode_significant_coeff_flag(picture, bs, mb_block_level, levelListIdx, 0, significant_coeff_flag[ i ]); //3 | 4 ae(v)
            RETURN_IF_FAILED(ret != 0, -1);

            if (significant_coeff_flag[ i ]) //position i has a non-zero value.
            {
                ret = CABAC_decode_significant_coeff_flag(picture, bs, mb_block_level, levelListIdx, 1, last_significant_coeff_flag[ i ]); //3 | 4 ae(v)
                RETURN_IF_FAILED(ret != 0, -1);

                if (last_significant_coeff_flag[ i ]) //all following transform coefficient levels (in scanning order) of the block have value equal to 0.
                {
                    numCoeff = i + 1; //跳出循环，因为剩下的DCT变换系数都是0了
                }
            }

            i++;
        }

        //-----------------------------------
        ret = CABAC_decode_coeff_abs_level_minus1(picture, bs, mb_block_level, numDecodAbsLevelEq1, numDecodAbsLevelGt1, coeff_abs_level_minus1[ numCoeff - 1 ]); //3 | 4 ae(v)
        RETURN_IF_FAILED(ret != 0, -1);

        ret = CABAC_decode_coeff_sign_flag(picture, bs, coeff_sign_flag[ numCoeff - 1 ]); //3 | 4 ae(v)
        RETURN_IF_FAILED(ret != 0, -1);

        coeffLevel[ numCoeff - 1 ] = (coeff_abs_level_minus1[ numCoeff - 1 ] + 1) * (1 - 2 * coeff_sign_flag[ numCoeff - 1 ]);

        index[0] = numCoeff - 1;
        TotalCoeff = 1;

        //------------------------------------------
        if (ABS(coeffLevel[ numCoeff - 1 ]) == 1)
        {
            numDecodAbsLevelEq1++;
        }
        else if (ABS(coeffLevel[ numCoeff - 1 ]) > 1)
        {
            numDecodAbsLevelGt1++;
        }
        
        //------------------------------------------
        for (i = numCoeff - 2; i >= startIdx; i--)
        {
            if (significant_coeff_flag[ i ])
            {
                index[TotalCoeff] = i;
                TotalCoeff++;

                ret = CABAC_decode_coeff_abs_level_minus1(picture, bs, mb_block_level, numDecodAbsLevelEq1, numDecodAbsLevelGt1, coeff_abs_level_minus1[ i ]); //3 | 4 ae(v)
                RETURN_IF_FAILED(ret != 0, -1);

                ret = CABAC_decode_coeff_sign_flag(picture, bs, coeff_sign_flag[ i ]); //3 | 4 ae(v)
                RETURN_IF_FAILED(ret != 0, -1);

                coeffLevel[ i ] = (coeff_abs_level_minus1[ i ] + 1) * (1 - 2 * coeff_sign_flag[ i ]);

                //------------------------------------------
                if (ABS(coeffLevel[ i ]) == 1)
                {
                    numDecodAbsLevelEq1++;
                }
                else if (ABS(coeffLevel[ i ]) > 1)
                {
                    numDecodAbsLevelGt1++;
                }
            }
        }

        //--------------将coded_block_flag值保存起来----------------------------------------
        if (mb_block_level == MB_RESIDUAL_Intra16x16DCLevel
            || mb_block_level == MB_RESIDUAL_ChromaDCLevel
            || mb_block_level == MB_RESIDUAL_CbIntra16x16DCLevel
            || mb_block_level == MB_RESIDUAL_CrIntra16x16DCLevel
            ) //for DC
        {
            picture.m_mbs[picture.CurrMbAddr].coded_block_flag_DC_pattern ^= 1 << (iCbCr + 1); //iCbCr=-1 --> luma, iCbCr=0 --> cb, iCbCr=1 --> cr
        }
        else  //for AC
        {
            picture.m_mbs[picture.CurrMbAddr].coded_block_flag_AC_pattern[iCbCr + 1] ^= 1 << BlkIdx; //iCbCr=-1 --> luma, iCbCr=0 --> cb, iCbCr=1 --> cr
        }
    }
    
    if (picture.m_PicNumCnt == -1)
    {
        printf("%s(%d): mb_x=%d; mb_y=%d; TotalCoeff=%d;\n", __FUNCTION__, __LINE__, picture.mb_x, picture.mb_y, TotalCoeff);
        for (i = 0; i < TotalCoeff; i++)
        {
            printf(" %d", coeffLevel[index[i]]);
        }
        if (TotalCoeff > 0)
        {
            printf("\n");
        }
    }

    return 0;
}

